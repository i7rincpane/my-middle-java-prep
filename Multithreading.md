# Многопоточность (Multithreading)
* ### [Процесс и Поток (Основы ОС)](#process-p)
* ### [Java Memory Model](#jmm-java-memory-model-p)

## <a id="process-p">Процесс и Поток (Основы ОС)</a>

Процессы изолированы ради **безопасности** (защита данных), а потоки делят общую память ради **скорости**. Изоляция процессов реализуется через механизм **Виртуальной памяти**.

### 1. Почему процессы изолированы? (Концепция безопасности)
На уровне ОС изоляция процессов — это главный барьер защиты.
* **Пример:** Представь, что запущено банковское приложение и мессенджер. Если бы процессы имели доступ к общей памяти, мессенджер мог бы зайти в память банка и изменить твой баланс с $200 на $0.
* **Механизм:** На физическом уровне (в плашке ОЗУ) данные разных приложений могут лежать на соседних ячейках, однако ОС подменяет реальные адреса виртуальными. Процесс А физически не может обратиться к памяти Процесса Б, потому что он просто не знает его реального адреса. Он знает только свои "вымышленные" (виртуальные) координаты.
* **Результат:** Если Процесс А упадет с `OutOfMemoryError`, он просто исчерпает свой лимит. Процесс Б этого даже не заметит, так как его "виртуальный мир" никак не связан с миром Процесса А.
* **Процессор (CPU):** Общий ресурс. Если один процесс (или поток внутри него) загрузит CPU на 100%, все остальные приложения в системе начнут тормозить, так как им не хватит "времени" на выполнение.

### 2. Межпроцессное взаимодействие (IPC)
Так как процессы изолированы, для общения им нужны "посредники" (протоколы):
* **REST / gRPC / Sockets:** Общение через сообщения. Это как передача письма через забор — официально и безопасно.
* **Файлы / БД:** Обмен данными через внешнее хранилище.
* **CORBA:** Устаревший протокол для вызова методов между разными процессами.
* **Shared Memory:** Редкий механизм, когда ОС выделяет кусок памяти, видимый обоим процессам.

### 3. Потоки: Жизнь без стен и JMM
Внутри одного процесса у потоков **нет никаких стен**. Они все видят общую память (**Heap**).
* **Плюс:** Это мгновенно. Не нужно пересылать сообщения, можно просто положить объект на "общий стол".
* **Минус:** Это рождает хаос. Именно из-за отсутствия изоляции в памяти нам и нужны правила **JMM (Happens-Before)**, чтобы потоки не затирали данные друг друга(Race Condition) и видели изменения.

## <a id="jmm-java-memory-model-p">JMM (Java Memory Model)</a>

- Модель памяти джава (JLS 17.4) на логическом уровне представляет память в виде хипа и стека, абстрагируясь от физического уровня. Она описывает взаимодействие потоков с хипом как с общей разделяемой памятью.
- Без JMM потоки будут друг друга затерать и не будут видеть изменений друг друга.

JMM это объяснение как потокам работать с общей памятью. Предупреждает о DATA RACE конфликтах, связанных с оптимизациями (переупорядочивание или кэширование). В результате них потоки могут не видеть изменения друг друга. JMM описывает правила, которые позволяют этих конфликтов избегать. Она говорит: Неважно, как устроено железо, но если ты используешь volatile, второй поток увидит изменения.

1. Проблема перестановки (Reordering): процессор может менять порядок строк кода для ускорения. Другой поток может прочитать некорректные данные, не заметив перестановки. (Пример [Алгоритм Деккера](#code-dekker))
2. Проблема видимости (Visibility): процессоры работают со своим кэшем и не всегда ходят в RAM напрямую. Потоки могут видеть устаревшие данные.
3. Проблема атомарности: чтение и запись типов long и double может происходить в два шага (по 32 бита). В итоге поток может прочитать "половинчатое" некорректное число.

Во всем остальном JMM гарантирует отсутствие "придуманных" чисел (out-of-thin-air). Чтение вернет либо значение по умолчанию (0, null, false), либо то, что записал другой поток (при наличии HB).

### Решение: Happens-Before (HB)

JMM создает HB-связи между действиями. Если есть HB-связь, модель гарантирует, что оптимизации не будут применены и потоки смогут друг друга читать. (Пример [Анализ по HB](#hb-analyze))

5 основных правил HB:
1. Program Order: операции в одном потоке видят то, что было изменено перед ними.
2. Monitor Lock: захвативший монитор видит изменения того, кто этот же монитор отпустил.
3. Volatile Variable: запись в volatile ставит Memory Barrier, сбрасывает данные в RAM и транзитивно гарантирует видимость операций выше (Пример [Memory Barrier](#memory-barrier)). Также делает операции с long и double атомарными.
4. Thread Start/Join: новый поток видит данные родителя до старта, а родитель — данные завершенного потока после join.
5. Final Fields: поля final, инициализированные в конструкторе без утечки this, гарантированно читаются всеми без синхронизации.

### Data Race vs Race Condition

1. **Data Race** — когда потоки не могут прочитать изменения (проблема видимости).
2. **Race Condition** — когда изменения записываются некорректно, с потерянными обновлениями (Lost Update).
   (Пример [Data Race and Race Condition](#data_and_race_condition))

### Итог: Что значит понимание JMM для разработчика

1. Осознание, что код выполняется не так, как написан (оптимизации повсюду).
2. Знание, что гарантии дает только отношение **happens-before**.
3. Привычка при анализе многопоточного кода спрашивать: «Есть ли здесь happens-before связь между записью и последующим чтением?»

Если связи нет — это **data race**, и код нужно исправлять:
* **volatile** — для флагов и однократной публикации.
* **synchronized** — для сложных составных операций.
* **атомики** — для счетчиков.
* **java.util.concurrent** — для бизнесс сценариев.

### Приложение №1: Пример переупорядочивания (Алгоритм Деккера)

Программист ожидает результат (1,1), (1,0) или (0,1). Но из-за перестановки чтение может произойти раньше записи в обоих потоках, что приведет к результату (0,0).

```java
// Глобальное состояние
int x = 0, y = 0;

// Поток 1          // Поток 2
x = 1;              y = 1;
int r1 = y;         int r2 = x; 
```

<a id="memory-barrier"></a>
### Приложение №2: Как работает Memory Barrier (volatile)
```java
int a = 1;
int b = 2;
volatile boolean flag = true; // Эта строчка "заблокирована" Memory Barrier
int c = 3; // Гарантированно выполнится ПОСЛЕ присвоения flag = true
```

### Приложение №3: Анализ по HB (Транзитивность)
```java
// Исходные данные
int x = 0;
// атомики используют volatile-флаг
AtomicBoolean flag = new AtomicBoolean(false);

// Поток 1
x = 100;                 // (1) Обычная запись
flag.set(true);          // (2) Volatile-запись

// Поток 2
if (flag.get()) {        // (3) Volatile-чтение
System.out.println(x); // (4) Обычное чтение
}
```

1. В потоке 1: **(1) hb (2)** по правилу Program Order.
2. Между потоками: **(2) hb (3)** по правилу Volatile.
3. В потоке 2: **(3) hb (4)** по правилу Program Order.
4. **По транзитивности:** (1) hb (2) + (2) hb (3) + (3) hb (4) = **(1) hb (4)**.

Вывод: Поток 2 гарантированно увидит корректное значение x = 100.

### Приложение №4: Data Race and Race Condition

```java
class Counter {
private int count = 0;
public void increment() { count++; } // не атомарно: read-modify-write
public int getCount() { return count; }
}
```

* **Data Race?** Да. Если нет volatile/synchronized на count, JMM допускает Data Race. Чтение в getCount() и операции в increment() не связаны HB с другими потоками.
* **Race Condition?** Да. Операция count++ не атомарна, при одновременном доступе инкременты будут теряться.

### Приложение №5: Про «утечку» конструктора

```java
public class Dasy {
int x;
public Dasy() {
x = 10;
Global.instance = this; // "Публикация" ссылки до завершения конструктора
}
}
```
Может ли другой поток, обратившись к Global.instance, увидеть x = 0, а не 10? Как здесь работает (или ломается) JMM?

Ответ:
x может привести к data race непредсказуемому результату, потомучто между записью в x и записью в глобальную переменную текущего объекта, нет HB. В таком случае JMM не гарантирует, что результат будет ожидаем. HB между этими операциями можно получить, если сделать int volataile, тогда операция заблокируется и не переместиться ниже записи this. тагже можно объявить переменную final, есть гарантия что final переменная записанная в конце конструтора, даже если она создает утечку this, все равно выполнится последней. главное чтобы сылка не утекла до завершения конструктора. В противном случае другой поток может прочитать дефолтное значение.

### Приложение №6: Транзитивность и обычные переменные
```java
// Поток А
x = 42;
v = true; // volatile

// Поток Б
if (v == true) {
print(x);
}
```
Гарантирует ли JMM, что Поток Б увидит x = 42? Почему?

Ответ:
да, между чтением v и x есть транзитивная HB связь.
v блокирует переупорядочевание, согласно JMM, процессор не сможет переместить v выше операции x. В итоге есть гарантия, что если она станет true, x транзитивно уже будет равен 42.

### Приложение №7: Синхронизация по разным объектам
Будет ли установлена связь Happens-Before, если Поток А записал данные внутри synchronized(lock1), а Поток Б читает их внутри synchronized(lock2)?

Ответ:
Нет, связи HB не будет, так как потоки захватывают разные мониторы, и совсем не обязательно что поток Б дождется выполнения записи потока A и сброса его изменений в общую память.