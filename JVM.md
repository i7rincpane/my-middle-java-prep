# JVM (Java Virtual Machine)
* ### [Структура памяти JVM](#структура-памяти-jvm-java-virtual-machine)
* ### [Сборка мусора (Garbage Collection)](#сборка-мусора-garbage-collection))
* ### [Виды Garbage Collectors (GC) и их алгоритмы](#виды-garbage-collectors-gc-и-их-алгоритмы)
* ### [Утечки памяти (Memory Leaks)](#утечки-памяти-memory-leaks)
* ### [Типы ссылок в Java](#типы-ссылок-в-java)
* ### [Диагностика и профилирование](#диагностика-и-профилирование)

## Структура памяти JVM (Java Virtual Machine)

При запуске приложения операционная система выделяет процессу кусок памяти. Java делит его на две большие части: **Heap** (управляется сборщиком мусора) и всё остальное.

> **Ключевой момент:** Общий объем оперативной памяти, которую занимает весь процесс Java (Native Memory), включает в себя: **Heap + Metaspace + Code Cache + Stacks потоков**. Поэтому потребление памяти процессом всегда выше, чем указанный `-Xmx`.

### Хип - самая большая часть памяти

Здесь живут все объекты и массивы. Хотя хип выглядит как единое целое, почти все GC (кроме новых) делят его на **Young Generation** (Eden + Survivor — короткоживущие объекты) и **Old Generation** (долгоживущие объекты, прошедшие несколько очисток, их не трогают Young сборки).

В хипе также хранятся специфические области оптимизации:

* **Integer Pool**: Кеш для объектов-оберток в диапазоне **от -128 до 127**.
    * Позволяет не создавать новые объекты в хипе при автоупаковке (`Integer a = 10`).
    * **Важно:** Верхнюю границу пула (127) можно увеличить с помощью параметра `-XX:AutoBoxCacheMax=<size>`, если приложение работает с большим количеством уникальных чисел.
* **String Pool**: Кеш для строк-литералов (созданных через `""`).
    * Строки — это **immutable** объекты. Работа с ними происходит постоянно, поэтому для оптимизации (переиспользования одинаковых строк) был создан пул.
    * С Java 7 пул находится **внутри Heap**, чтобы сборщик мусора мог его чистить.
    * Создание через `new String("abc")` создает объект в хипе, минуя пул. Метод `.intern()` позволяет вручную поместить строку в пул и вернуть ссылку на неё.
    * *Пример, как забить Хип через пул в бесконечном цикле:* `String s = (UUID.randomUUID().toString()).intern();`

### Stack - Память потоков
У каждого потока свой стек. Это очень быстрая память, работающая по принципу **LIFO** (последним пришел — первым ушел).
Она хранит локальные переменные, примитивы и ссылки на объекты. Каждый вызов метода занимает память — **Фрейм**.
* **Фрейм** — это структура данных, которая создается при каждом вызове метода и содержит его локальные переменные, аргументы и данные для возврата управления.
* По умолчанию размер стека около 1 Мб. Бесконечная рекурсия приводит к `StackOverflowError`.

### Metaspace - Область метаданных
Находится вне хипа (в Native Memory). Здесь хранится описание классов и их байт-код. Фреймворки (Spring, Hibernate) генерируют новые прокси-классы во время работы программы, поэтому Metaspace может разрастаться и «съесть» всю память сервера, так как по умолчанию не ограничен. Раньше эту роль выполнял **PermGen** в составе хипа, что часто вызывало `OutOfMemoryError`.

### Code Cache - Кеш для JIT
Область памяти для работы JIT-компилятора. JVM сначала **интерпретирует** байт-код (переводит строчка за строчкой), что позволяет коду работать на разных ОС, но медленно.
Если метод вызывается часто, **JIT** компилирует его в машинный код целиком и кеширует в **Code Cache**. Область имеет фиксированный размер; если она забивается, оптимизация прекращается и приложение замедляется.

### Исключения, связанные с памятью

* **StackOverflowError**: Переполнение стека фреймами (бесконечная рекурсия).
* **OutOfMemoryError (Java heap space)**: Хип забит «живыми» объектами, GC не может их удалить.
* **OutOfMemoryError (Metaspace)**: Утечка памяти в области метаданных (слишком много сгенерированных классов).

---

# Сборка мусора (Garbage Collection)

> **Ключевой момент:** JVM не ищет мусор. Она ищет **живых**, а всё остальное считает пустотой. Работа GC основана на **гипотезе о поколениях**: большинство объектов живут очень недолго. Поэтому вместо одной тяжелой уборки во всей памяти, JVM делает множество быстрых «микро-уборок» в молодой области (Young Gen).

### Как GC понимает, что объект — мусор?
JVM использует алгоритм **достижимости (Reachability Analysis)**. Сборщик ищет объекты, начиная от **GC Roots**:
*   **Активные потоки**: пока поток жив, всё в его стеке — корни.
*   **Локальные переменные** и параметры методов в стеках.
*   **Статические переменные** классов.

Если объект «оторван» от этих корней (даже если есть циклические ссылки типа А <-> Б) — он считается мусором.

### Жизненный цикл объекта и возраст (Promotion)
1. **Рождение:** Новые объекты рождаются в **Eden**.
2. **Survivor зоны (S0 и S1):** При каждой Minor GC выжившие объекты перемещаются в свободную зону Survivor. Эти зоны нужны для **уплотнения** памяти: объекты копируются в чистое место друг за другом без «дырок» (фрагментации).
3. **Возраст объекта (Age):**
   У каждого объекта в заголовке (Header) есть 4 бита под «счетчик выживания».
  * Выжил в сборке — возраст увеличился на +1.
  * Максимальный порог — **15** (больше 4 бита не позволяют).
  * **Нюанс:** Если Survivor-зона забита более чем на 50%, JVM может принудительно снизить порог (например, до 3), чтобы поскорее выкинуть «старичков» в Old Generation.
4. **Promotion:** Когда возраст достигает порога, объект переезжает в **Old Generation**.

### Фазы работы и STW
*   **Minor GC**: Быстрая чистка только Young Generation.
*   **Full GC**: Тяжелая чистка всего Хипа и Metaspace.
*   **Stop The World (STW)**: Фаза, когда JVM приостанавливает все потоки приложения, чтобы безопасно переместить объекты. Современные GC борются за минимизацию этой паузы.


### Практика: Расчет занимаемой памяти (64-bit JVM)

Чтобы понимать нагрузку на GC, нужно учитывать, что память в JVM всегда выравнивается по **8 байт** (Padding). Если объект занимает 21 байт, JVM «докинет» 3 байта пустоты, чтобы получилось 24.

**Правила веса для 64-bit JVM:**

* **Заголовок (Header):** 12–16 байт (содержит информацию для сборщика мусора и данные о блокировках).
* **Примитивы:**
  * double / long — **8 байт**
  * int / float — **4 байта**
  * short / char — **2 байта**
  * boolean / byte — **1 байт**
* **Ссылки на объекты:** **4 байта** (при включенном сжатии указателей CompressedOops, что является стандартом).

**Нюансы для точного подсчета:**
1. **Массивы:** Имеют дополнительное поле в заголовке — длина массива (4 байта).
2. **Объекты-обертки:** Занимают намного больше места (например, Integer весит 16–24 байта вместо 4 байт у примитива int).
3. **Порядок полей:** JVM может переставлять поля в памяти для оптимизации места, независимо от того, как они объявлены в коде.

**Пример расчета для класса User:**

public class User {
private int age;      // 4 байта
private String name;  // 4 байта (ссылка)
}

1. **Объект User:** Заголовок (16) + age (4) + ref (4) = **24 байта**. (Уже кратно 8, выравнивание не требуется).
2. **Объект String:** Заголовок (16) + 3 вспомогательных int поля (hash, coder и др. — 12) + ссылка на массив (4) = **32 байта**.
3. **Массив внутри String:** Заголовок (16) + длина int (4) + данные (например, 5 английских символов по 1 байту = 5) = 25 байт.
  * *Выравнивание:* 25 дополняется до **32 байт**.

**Итого:** Для объекта u1 с именем из 5 символов: 24 (User) + 32 (String) + 32 (массив) = **88 байт**.

**Прогноз поведения GC и проблема finalize()**

Если в цикле создать **1000** таких объектов без сохранения ссылок:
1. Около **80–100 КБ** данных мгновенно заполнят Eden.
2. **Обычный сценарий:** При первой же Minor GC все 1000 объектов будут удалены сразу, так как на них нет ссылок из GC Roots (стека). В Survivor переедет только тот объект (u1), ссылка на который сохранена в переменной.

**Осложнение с методом finalize():**
Сборка осложняется, если переопределен метод finalize(). Все 1000 временных объектов не могут быть утилизированы сразу.
* Вместо этого они помещаются в **очередь финализации**, где ожидают выполнения finalize() в отдельном фоновом потоке.
* Это заставляет объекты **пережить несколько лишних сборок мусора**.
* При достаточно большом объеме данных или медленной работе потока финализации они могут быть преждевременно перемещены (**promoted**) из Young Generation в **Old Generation**.
* Там они остаются надолго, значительно снижая эффективность управления памятью и вызывая преждевременные Full GC.

---

## Виды Garbage Collectors (GC) и их алгоритмы

> Ключевой момент: Эволюция сборщиков мусора — это борьба за сокращение пауз STW. Мы переходим от простой остановки всего мира (Serial/Parallel) к фоновой пометке мусора (CMS/G1) и, наконец, к фоновому перемещению объектов (ZGC), платя за это ресурсами процессора и памятью.
Выбор сборщика — это баланс между пропускной способностью (производительностью), паузами STW и потреблением памяти. Это называют «Золотым треугольником GC», где нельзя улучшить всё сразу.


### 1. Serial GC (`-XX:+UseSerialGC`)

*   **Применение:** Подходит для программ с небольшими размерами кучи и одноядерных процессоров. Содержит базовые подходы сборки мусора.
*   **Механика:** Использует один поток и полностью останавливает приложение на время любой сборки (**STW**).
*   **Младшее поколение (Young Gen):** Использует копирование. Живые объекты из Eden и Survivor переносятся в пустой Survivor, выстраиваясь друг за другом, чтобы не было «дыр» (дефрагментация). Один из двух Survivor регионов всегда остается пустым.
*   **Старшее поколение (Tenured):** Использует алгоритм **Mark-Sweep-Compact**. Поскольку переносить объекты некуда, их помечают, чистят и уплотняются (сдвигают) в начале этого же региона. Размещаются последовательно без фрагментации.
*   **Объекты-акселераторы:** Из-за большого размера могут создаваться сразу в Tenured, чтобы не таскать их по Survivor-зонам.

### 2. Parallel GC (`-XX:+UseParallelGC`)

*   **Приоритет Throughput:** Ориентирован на максимальную пропускную способность (производительность). Например, за 100 секунд работы приложения: 95 секунд работает код (полезная работа), 5 секунд стоит сборщик мусора.
  *   *Для сравнения:* ZGC/CMS имеют низкий Throughput, так как постоянно отъедают ресурсы процессора в фоне, из-за чего код работает медленнее, но плавно.
*   **Механика:** Выполняет те же задачи, что и Serial, но в несколько потоков. И малая, и полная сборки здесь многопоточные.
*   **Promotion Buffer:** Каждый поток переносит объекты в свой личный участок региона Old Gen (буфер повышения), чтобы не мешать другим. Это ускоряет сборку, но может немного фрагментировать память.
*   **Адаптивность:** Умеет автоматически подстраиваться под нужную пропускную способность или размер пауз (Ergonomics), меняя размеры регионов на основе статистики. Если паузы длинные — уменьшает кучу, если нужна скорость — увеличивает.
*   **STW:** Происходит на все время работы сборщика, как и в Serial, но за счет многопоточности паузы значительно короче.

### 3. CMS (Concurrent Mark Sweep) — `-XX:+UseConcMarkSweepGC`

*   **Тип сборщика:** CMS и G1 называются **Mostly Concurrent** сборщиками, так как большая часть их работы по поиску мусора выполняется параллельно с основным кодом. Это улучшает ситуацию с паузами, но нагружает процессор и снижает общую производительность.
*   **Организация:** Малая и старшая сборки здесь всегда раздельны. Старшая сборка не делает уплотнение, что приводит к фрагментации памяти (главный минус).
*   **Главный минус:** Не делает уплотнение в старшем поколении, что приводит к фрагментации памяти

**Этапы сборки в старшем поколении:**

1.  **Initial Mark (STW):** Короткая остановка приложения для пометки объектов, доступных напрямую из корней.
2.  **Concurrent Mark (Фоново):** Приложение продолжает работу, а сборщик в это время ищет остальные живые объекты.
3.  **Remark (STW):** Вторая пауза для актуализации списка — ищутся объекты, которые приложение создало или изменило, пока шел фоновый поиск.
  *   Здесь используется алгоритм **Snapshot-At-The-Beginning (SATB)**: в список живых попадают те, кто был жив на момент начала сборки.
  *   **Плавающий мусор:** Объекты, которые умерли в процессе работы алгоритма, всё равно считаются живыми и удалятся только в следующий раз.
4.  **Concurrent Sweep (Фоново):** После актуализации работа приложения возобновляется, а сборщик параллельно всё подчищает.

### 4. G1 (Garbage First) — `-XX:+UseG1GC`

*   **Организация:** Полностью меняет организацию кучи, разделяя её на множество одинаковых регионов. Регионы могут быть Eden, Survivor или Old, и они не обязаны идти подряд.
*   **Малые сборки:** Всегда происходят с **STW**, но очищается не всё поколение, а только самые загруженные мусором регионы (Garbage First), чтобы уложиться в заданное время пауз.
*   **Смешанные сборки (Mixed GC):** G1 не делает «чистый» Major GC как CMS. Вместо этого он использует Mixed GC. Запускаются при заполнении старшего поколения. Состоят из фаз:
  1.  Короткая пометка корней (**STW**).
  2.  Фоновый поиск живых объектов (**Конкурентно**).
  3.  Длинная пауза **Remark** для актуализации списка по алгоритму **SATB** (**STW**).
  4.  Cleanup (**STW/Concurrent**): Подсчет живых объектов в регионах и выбор кандидатов на очистку.
  5.  Evacuation (**STW**): Вот тут магия G1 — он копирует живые объекты из выбранных регионов в новые пустые регионы, достигая уплотнения (дефрагментации). В CMS на этом этапе была просто очистка на месте («дырки»).
*   **Humongous объекты:** Если объекты слишком большие (больше половины региона), под них выделяются цепочки регионов, которые никогда не перемещаются.

### 5. ZGC (Z Garbage Collector) — `-XX:+UseZGC`

*   **Производительность:** Самый современный сборщик, где паузы **STW всегда меньше 1 мс** независимо от размера кучи.
*   **Конкурентность:** Почти все этапы, включая перемещение объектов и уплотнение памяти, происходят фоново, одновременно с работой кода приложения.
*   **Colored Pointers:** Информация о том, перемещен объект или нет, хранится прямо в битах ссылки (цветные указатели).
*   **Load Barrier & Self-healing:** Если код обращается к объекту, который в этот момент «переезжает», специальный барьер чтения видит «неправильный цвет» ссылки и за наносекунды сам исправляет адрес в переменной на актуальный.
*   **Итог:** Это называется «самолечение» ссылок, и это единственный способ избежать длительных STW при перемещении данных.

### 6. Epsilon GC (No-Op Garbage Collector)  — `-XX:+UseEpsilonGC`

Это сборщик мусора, который не выполняет сборку мусора вообще, то есть игнорирует очистку памяти. Он лишь выделяет память, а при ее исчерпании вызывает OutOfMemoryError, что делает его подходящим для коротких задач, бенчмарков или приложений с ручным управлением.

*   **«No-Op» (без операций):** Не занимается поиском и удалением мусора.
*   **Использование:** Применяется в ситуациях, когда гарантируется, что приложение не исчерпает память, например, в тестах производительности, CI/CD или в кратковременных задачах.
*   **Преимущества:** Предоставляет предельно низкие накладные расходы, не снижая пропускную способность приложения паузами.

Epsilon GC разработан для случаев, когда сборка мусора не требуется, позволяя анализировать производительность без накладных расходов на GC

---

## Утечки памяти (Memory Leaks)

> **Ключевой момент:** Утечка памяти в Java - это не "исчезновение" памяти, а удержание ненужных объектов. Основная коварность утечек заключается в старении мусора: если объект не успел удалиться в Young Gen, он уходит в Old Gen, где Full GC будет пытаться достать его ценой огромных пауз.

### Анализ практического кейса (Разбор домашки)

В ходе анализа [приложения](./samples/jvm/leak/Menu.java) по генерации постов было выявлено, как типичные ошибки проектирования приводят к деградации памяти.

#### Применение инструментов JDK для анализа:
Для мониторинга использовалась утилита **jmap -histo**. Она показала аномалию: несмотря на то, что коллекции перезаписывались, в хипе находилось **4049 User и 250 Comment**, хотя ожидалось ровно **1000 User и 50 Comment**.
**Вывод:** Объекты «протекали» из прошлых итераций цикла, не успевая утилизироваться сборщиком.

#### Роль Finalizers в утечке:
В классах **User**, **Comment** и **Post** был переопределен метод `finalize()`.
* **Механика проблемы:** Каждую итерацию создается 1000 пользователей. Ссылки на старые объекты обнуляются, но из-за финализаторов они не могут быть удалены мгновенно. Они помещаются в очередь финализации и ожидают выполнения в отдельном потоке.
* **Результат:** Объекты не успевают собраться «молодым» сборщиком, проходят **15 циклов выживания** и перемещаются в старшее поколение (**Old Generation**), где продолжают накапливаться. Это провоцирует тяжелые **Full GC**.
* **Решение:** После удаления методов `finalize()` количество объектов в хипе стало соответствовать реально созданному (1000 User + 50 Comment + 100 Post), а количество Full GC упало с **2 до 0**.

### Основные причины утечек памяти:
1. **Статические коллекции:** Объекты удерживаются ссылками на протяжении всей работы программы и быстро попадают в старший регион.
2. **Финалайзеры (finalize):** Заставляют объекты выживать дольше положенного, перегружают очередь финализации и «проталкивают» мусор в Old Gen.
3. **Незакрытые ресурсы:** Не закрытые потоки (Streams), сокеты или соединения с БД.
4. **Непереопределенные equals/hashCode:** Объекты дублируются в HashMap/Set, так как их невозможно найти для удаления.
5. **Хешкоды в HashMap:** Изменение поля объекта, который является ключом, делает его недоступным для поиска и удаления.
6. **Внутренние классы:** Нестатические вложенные классы держат скрытую ссылку на экземпляр внешнего класса.

### Рекомендации по исправлению:
* **Уменьшать область видимости:** Не делать объект полем класса, если его можно объявить внутри метода или блока `if`.
* **Явная чистка:** Обнулять ссылки или вызывать `.clear()` для коллекций, как в примере с `postStore.removeAll()`.
* **Отказ от финализаторов:** Применять `try-with-resources` для закрытия ресурсов.
* **Слабые ссылки:** Использовать `WeakReference` для реализации кэшей.

### String vs StringBuilder: Влияние на память

**В чем разница на уровне памяти:**

1. **String (Неизменяемый):**
* Каждое изменение строки (конкатенация `+`) в цикле создает **новый объект** в Хипе.
* Старые промежуточные строки мгновенно становятся мусором и забивают **Young Generation**.
* Если строк много, сборщик мусора (GC) начинает работать постоянно, снижая производительность приложения.

2. **StringBuilder (Изменяемый):**
* Работает с **одним объектом** и внутренним массивом символов.
* Метод `.append()` просто дописывает символы в уже существующий массив в памяти.
* Это гораздо эффективнее: вместо тысячи объектов-строк в Хипе лежит всего один объект-билдер.
* Если идет любая работа со строками в **цикле** используется только `StringBuilder`.

### Примеры кода с утечкой (Anti-patterns)

```java
// --- КЛАСС USER (Проблема: Финализатор задерживает очистку) ---
package vitaliy.gc.leak;

public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    @Override
    protected void finalize() throws Throwable {
        // Пустой финализатор заставляет объект прожить +15 сборок мусора
        super.finalize();
    }
}

// --- КЛАСС POSTSTORE (Проблема: Статическая коллекция живет вечно) ---
package vitaliy.gc.leak;

import java.util.*;

public class PostStore {
    // Статическая коллекция — объекты сразу претендуют на Old Generation
    private static final Map<Integer, Post> POSTS = new HashMap<>();

    public void removeAll() {
        // Явная чистка коллекции. Без неё объекты не удалятся никогда.
        POSTS.clear(); 
    }
    
    public Post add(Post post) {
        // Добавление в статическую карту
        POSTS.put(post.getId(), post);
        return post;
    }
}

// --- КЛАСС USERGENERATOR (Проблема: Массовое создание объектов в статике) ---
package vitaliy.gc.leak;

import java.util.*;

public class UserGenerator implements Generate {
    public static final Integer NEW_USERS = 1000;
    // Коллекция USERS удерживает 1000 ссылок в памяти
    private static final List<User> USERS = new ArrayList<>();

    @Override
    public void generate() {
        USERS.clear(); // Обнуление ссылок, но объекты ждут очереди финализации
        for (int i = 0; i < NEW_USERS; i++) {
            // Массовое создание 1000 объектов за один вызов
            USERS.add(new User("User " + i));
        }
    }
}

// --- КЛАСС MENU (Проблема: Циклическая нагрузка на память) ---
package vitaliy.gc.leak;

public class Menu {
    // Метод, который провоцирует лавинообразный рост объектов
    private static void createPost(CommentGenerator commentGenerator,
                                   UserGenerator userGenerator, PostStore postStore, String text) {
        // Каждый вызов создает 1000 User + 50 Comment
        userGenerator.generate();
        commentGenerator.generate();
        
        // Создание поста и добавление в хранилище
        postStore.add(new Post(text, CommentGenerator.getComments()));
    }

    // Вызов в цикле из main/start:
    // for (int i = 0; i < Integer.parseInt(count); i++) {
    //     createPost(...); 
    // }
}
```

---

## Типы ссылок в Java

В Java существует 4 типа ссылок, которые по-разному сигнализируют сборщику мусора (GC), можно ли удалять объект.

### 1. Strong Reference [(Сильная ссылка)](./samples/jvm/references/StrongDemo.java)
Самый распространенный тип. Создается обычным оператором `new`.
* **Поведение GC:** Объект не будет удален, пока до него можно дойти от **GC Roots** (корней).
* **GC Roots:** Точки входа в приложение (локальные переменные в стеке потока `main` или других потоков, статические переменные классов).
* **Нюанс (Внутренние классы):** Нестатический внутренний класс держит скрытую ссылку на внешний объект. Если ты удерживаешь внутренний объект, внешний тоже не удалится.
  * *Рекомендация:* Если внутренний класс не использует поля внешнего — делай его **статическим** (`static nested class`), чтобы избежать утечки.

### 2. Soft Reference [(Мягкая ссылка)](./samples/jvm/references/SoftDemo.java)

* **Поведение GC:** Удаляется **только при нехватке памяти** (перед тем, как выбросить `OutOfMemoryError`).
* **Зачем:** Идеально для кэшей. Мы хотим держать объекты в памяти, пока места много, но готовы ими пожертвовать ради выживания приложения.

### 3. Weak Reference [(Слабая ссылка)](./samples/jvm/references/WeakDemo.java)
* **Поведение GC:** Удаляется при **первой же сборке мусора**, если на объект не осталось сильных ссылок.
* **Зачем:** Используется в `WeakHashMap`. Удобно, когда нужно привязать какие-то данные к объекту, пока он "живет" в основной логике. Как только сильная ссылка исчезла — слабая не мешает GC мгновенно утилизировать объект.

### 4. Phantom Reference [(Фантомная ссылка)](./samples/jvm/references/PhantomDemo.java)
Самая слабая. Не дает доступа к самому объекту (метод `.get()` всегда вернет `null`).
* **Поведение:** Используется вместе с очередью (`ReferenceQueue`).
* **Зачем:** Позволяет узнать, что объект уже удален из памяти, чтобы выполнить сложную очистку ресурсов (например, закрыть нативные соединения или удалить временные файлы), что является более безопасной альтернативой методу `finalize()`.

### Циклические ссылки (А <-> Б)
Если два объекта ссылаются друг на друга, но на них никто не ссылается из GC Roots, GC все равно удалит их. Современный GC (алгоритм Reachability Analysis) умеет находить такие "оторванные" группы объектов.


---

## Диагностика и профилирование

> **Ключевой момент:** Профилировщик — это инструмент, который анализирует **динамику** работы кода (время, частоту вызовов, скорость заполнения памяти) и позволяют увидеть, на что тратится процессорное время и чем забит Хип на реальном работающем приложении.
«Профиль» (Profile) в данном контексте означает «Слепок поведения».


JDK Tools — конкретные утилиты (jstat, jmap, jstack).
Sampling/Instrumentation — это методы сбора данных, которые эти утилиты (или другие профилировщики) используют.


### 1. Инструменты диагностики (JDK Tools

**Что это:** Готовые программы из поставки JDK для мониторинга JVM.

| Инструмент | Что делает | Пример команды |
|------------|------------|----------------|
| **jstat**  | Мониторинг GC. Позволяет увидеть цифры: сколько мусора собрано, как часто идут сборки | `jstat -gc <pid> 1s` |
| **jmap**   | Работа с памятью. Позволяет увидеть гистограмму объектов или снять **Heap Dump** (полный слепок памяти). | `jmap -histo:live <pid>` |
| **jstack** | Снимок всех потоков. Нужен, чтобы найти **Deadlock** (взаимную блокировку) — когда два потока замерли в ожидании друг друга. | `jstack <pid> > thread.txt` |


### 2. Виды профилировщиков (Sampling vs Instrumentation)

#### **VisualVM** Это **один инструмент** с **двумя разными методами** сбора данных
- Имеет **режим "Sampler"** (использует *Sampling* метод)
- Имеет **режим "Profiler"** (использует *Instrumentation* метод)

**Что это:** Два разных **подхода** к сбору данных о производительности.

#### **Sampling (Сэмплирующие) — «Серия снимков»**
* **Как работает:** Раз в несколько миллисекунд «фотографирует» стек потоков. Если метод часто попадает в кадр — значит, он «горячий» (занимает много времени).
* **Инструменты:** Режим **Sampler** в VisualVM, **JFR** (Java Flight Recorder).
* **Плюсы:** Низкая нагрузка (Overhead < 2%). Можно использовать на реальных серверах.

#### **Instrumentation (Инструментирующие) — «Вживление датчиков»**
* **Как работает:** Модифицирует байт-код методов, вставляя счетчики времени в каждую строчку.
* **Инструменты:** Режим **Profiler** в VisualVM, JProfiler.
* **Минусы:** Жутко тормозит систему. **Нельзя использовать на продакшене**.

**Пример: Анализ медленного метода**
Когда запускаем Sampler в VisualVM, видим **Call Tree**. Это визуализация того, какой метод «съел» процессор.

| Total Time (CPU) | Method |
| :--- | :--- |
| **100.0%** | `vitaliy.gc.leak.Menu.main()` |
| **98.2%** | `  --> Menu.start()` |
| **95.0%** | `    --> Menu.createPost()` |
| **85.5%** | `      --> UserGenerator.generate()`  <-- **Аномалия здесь!** |
| **8.3%** | `      --> CommentGenerator.generate()` |

**Анализ:** Мы видим, что 85% процессорного времени тратится внутри `UserGenerator.generate()`. Значит, оптимизировать нужно именно этот метод, а не меню или вывод текста.

- **JDK Tool подход:** Запустить `jstack` несколько раз, сравнить стеки вручную
- **Sampling подход:** Включить JFR на 5 минут, посмотреть "горячие методы"
- **Instrumentation подход:** Запустить профилировщик YourKit с точным замером всех вызовов

Любой инструмент мониторинга влияет на работу приложения (**эффект наблюдателя**). Например, VisualVM сам может провоцировать лишние сборки мусора в «стоячем» приложении, просто обновляя графики. Для «чистых» замеров на сервере лучше использовать легкие утилиты вроде **jstat**.

### Разбор ситуаций

**Вопрос: У меня приложение упало с OutOfMemoryError. Как мне поможет профилировщик?**
**Ответ:** Никак. Профилировщик смотрит только за **живым** процессом. Для анализа упавшего приложения нужен **Heap Dump** (посмертный слепок памяти). Его снимает `jmap` (если процесс еще висит) или JVM сама выгружает файл `.hprof` при падении (флаг `-XX:+HeapDumpOnOutOfMemoryError`). «Труп» анализируется в Eclipse MAT или VisualVM.

**Вопрос: В чем разница между jstack и Sampler? Мы же и там и там видим методы.**
**Ответ:** `jstack` — это **одиночное** фото. Ты видишь позу бегуна, но не знаешь его скорость. `Sampler` — это **серия** из 100 фото в секунду. Если на 90 фото из 100 повар стоит в подвале — значит, поход в подвал это самое узкое место.

**Вопрос: Почему Sampler запустился в VisualVM сразу, а Profiler выдал ошибку "settings invalid"?**
**Ответ:** Сэмплирование — это легкое подглядывание снаружи через MXBeans. Инструментирование (Profiler) — это тяжелое вторжение, попытка переписать код приложения на лету. JVM часто блокирует такие действия без специальных прав доступа.

**Вопрос: Так jstack — это Sampling или Instrumentation?**
**Ответ:** Ни то, ни другое! `jstack` — это **инструмент** (JDK Tool), который делает разовый снимок. Sampling — это когда таких снимков делается 100 в секунду и анализируется статистика.

**Вопрос: А JFR — это JDK Tool или метод?**
**Ответ:** И то, и другое! JFR — это **инструмент** (входит в JDK) и использует преимущественно **Sampling метод** для сбора данных

**Вопрос: Почему нельзя сказать "используй Sampling", а нужно уточнять инструмент?**
**Ответ:** Потому что разные инструменты, использующие Sampling, дают разный результат!
- **VisualVM Sampler** — базовый sampling
- **JFR** — sampling + запись событий JVM
- **async-profiler** — advanced sampling с точным учётом CPU времени

---




