# Собеседования
* ### [Инжиниринговый холдинг «эВ-групп»](#ev-group-p)

## <a id="ev-group-p">Инжиниринговый холдинг «эВ-групп»<a>
*Дата: 20 января 2026 | Позиция: Java Middle*

`#SQL` `#Hibernate`  `#Multithreading` `#JavaCore && OOP` `#JVM` `#Spring` `#REST`

### [SQL] 05:35  Снизу представлена наша БД в которой представлено 2 таблицы (User и car). Мы знаем что автомобили принадлежат этим пользователям, но у нас нигде это не написано. Нам нужно давать возможность записывать какой автомобиль кому принадлежит. Задача: У пользователей может быть много автомобилей, но у автомобиля может быть только один пользователь. Вы можете делать все что угодно, создавать таблицы или изменять существующие.
* **Мой ответ:** _В таблице машина нужен внешний ключ Foreign Key на таблицу юзера, кому какая машина принадлежит._
* **Интервьюер:** _А как бы вы назвали его?_
* **Мой ответ:** _user_id_.
* **Интервьюер:** _А кроме этого варианта еще какие-то есть, если по какой-то причине нам не подходит вариант с колонкой? Например у нас нет прав на изменение таблиц._
* **Мой ответ:** _Создать отдельную таблицу и там прописать связи user_id и car_id._
* **Интервьюер:** _Как бы назвали таблицу?_
* **Мой ответ:** _user_car._
* **Интервьюер:** _Колонки перечислите какие добавите._
* **Мой ответ:** _user_id и car_id и еще идентификатор id, можно его добавить, можно составной ключ использовать._
* **Интервьюер:** _А в каком случае вы бы использовали составной, а в каком создали бы id суррогатный? В данном случае какой вариант более уместен?_
* **Мой ответ:** _Из плюсов — удобнее по id обращаться, искать сразу записи. Из минусов — лишняя колонка появилась. (Анализ: тут я поплыл, начал говорить поверхностно)._
* **Интервьюер:** _То есть есть подход когда люди не задумываясь везде ставят суррогатный ключ, иногда у них спросишь зачем почему?_
* **Мой ответ:** _Чтобы проще было добраться до строки..._
* **Интервьюер:** _Какие будут основные запросы к этой таблице, user_car, русским языком._
* **Мой ответ:** _Машины для пользователя, какие у него есть._
* **Интервьюер:** _Ну либо по машине, какой пользователь у нее есть, то есть нам суррогатный ид даже не понадобится, мы будем выборки постоянно либо по одному либо по другому ключу._
* **Мой ответ:** _Да, возможно._

> **Анализ:** Не смог внятно объяснить преимущество составного ключа в связочной таблице. В связочной таблице суррогатный `id` часто избыточен и просто занимает место на диске, так как поиск всегда идет по `user_id` или `car_id`.  Вспомнил мой рабочий пример: идентификаторы записей постоянно удалялись и пересоздавались логикой приложения. При использовании суррогатных ID это приводило к тому, что я не мог идентифицировать уже существующую связь, считал её новой и плодил дубликаты. Использование натуральной связки (бизнес-полей) на уровне составного Primary Key позволило БД самой отсекать дубли и гарантировать уникальность, даже если технические ID объектов постоянно менялись.

**Материал:** [Классификация первичных ключей (Primary Keys)](SQL.md#primary-keys-p)

### [Hibernate] 11:30 Вы сказали, что есть нюансы работы с суррогатным ID в Hibernate. Можете проговорить этот момент?

* **Мой ответ:** _Помню, какая-то сложность есть при реализации связи «один-к-одному», когда нужно выбирать суррогатный или составной ключ, что именно — не помню._
* **Интервьюер:** _В каком случае нам будет обязателен именно суррогатный ключ? Или он всегда обязателен? Для чего вообще используется ключ в Hibernate?_
* **Мой ответ:** _Не помню, работал давно, была какая-то проблема._

> **Анализ:** Ссылался Hibernate, но небыл готов о нем поговорить. В итоге зациклился на «проблемах» в Hibernate связанных с ключами, пропустил остальные вопросы, на которые мог бы ответить. Стоило хотя бы сказать, что составной ключ не генерируется базой автоматически и требует ручного добавления при сохранении и создания отдельного класса. Если бы вовремя очнулся, сказал бы, что суррогатный ключ **не обязателен**, обязателен сам идентификатор (любого типа: натуральный, составной или суррогатный). Без @Id проект не скомпилируется, так как JPA спецификация требует наличия первичного ключа для каждой сущности.

**Материал:** [Работа Hibernate с ключами и контекстом](Hibernate.md#Работа-Hibernate-с-ключами-и-контекстом)

### [SQL] 13:02 А кроме суррогатных первичных ключей, еще какие бывают?

* **Мой ответ:** Ну, составной мы проговорили. 
* **Интервьюер:** А натуральный первичный ключ — это про что история?
* **Мой ответ:** По какой-то колонке, он не генерируется... по имени, например. 
* **Интервьюер:** В данном случае (в таблице user_car) у нас ID суррогатный, а user_id какой будет?
* **Мой ответ:** Натуральный. (Анализ: Угадал, так как продолжал думать, что натуральный — это просто "самописный", содержащий бизнес-информацию, а не просто подставляемый извне).

> **Анализ:** У меня слились определения составных и натуральных ключей. Понимаю что, суррогатный ключ — это "синтетика" (1, 2, 3), созданная только для БД, а натуральный ключ — это данные, которые существуют сами по себе (Email). Но внешний ключ user_id, вызвал у меня ступор, он вроде как не сгенерировался, просто подставился, и при этом это бессмысленный идендификатор, который сам по себе ни какой информации не несет. Получается что, в таблице связей `user_car` поля `user_id` и `car_id` являются натуральными, так как они ссылаются на уже существующие сущности. Если мы объединяем их в один ключ — он становится **составным натуральным ключом**.

**Материал:** [Классификация первичных ключей (Primary Keys)](SQL.md#primary-keys-p)

### [SQL] 14:36 У нас одна машина может принадлежать только одному человеку, а у человека может быть много машин. Отдельная таблица — это по сути заготовка под Many-to-Many. Как сделать так, чтобы одной машине нельзя было дать двух собственников?

* **Мой ответ**: _Констрейнт UNIQUE написать на связку (user_id, car_id)._
* **Интервьюер**: _Мы тогда не сможем задублировать именно связку (ту же машину тому же человеку), но одну машину мы сможем дать десяти разным людям спокойно._

> **Анализ:** Долго рассуждал, думал о сложных CHECK-констрейнтах, связывающих таблицы. Основная ошибка, что воспринял промежуточную таблицу как жесткий паттерн для Many-to-Many. В итоге с подсказкой дошел, что для поддержания One-To-Many (юзер - машины), достаточно просто запретить дублирование в колонке car_id. В конце концов, мы просто дублируем id в таблице car, и хотя бы только по этому должны сделать его PK или как минимум уникальным.

**Материал:** [Управление типом связи через ограничения (Constraints)](SQL.md#constraints-p)

### [SQL] 18:01 Если мы делаем составной первичный ключ на наши поля (user_id, car_id), нужен ли нам дополнительно составной констрейнт уникальности по этим же двум колонкам?

* **Мой ответ:** _Если мы делаем ключ первичным, то база автоматически добавляет ограничение уникальности. Поэтому прописывать его еще раз отдельно не нужно._

> **Анализ:** вроде правильно

* **Материал:** [Управление типом связи через ограничения (Constraints)](SQL.md#constraints-p)

### [SQL] 21:16 Сравним подходы: когда мы добавляем колонку (FK), а когда — отдельную таблицу связок? Вариант с колонкой проще, "из коробки". Какие минусы у колонки и сильные стороны у связочной таблицы? Когда таблица уместнее, даже если мы админы базы?

* **Мой ответ:** _Когда нет прав на изменение основной таблицы._
* **Интервьюер:** _Права не проблема._
* **Мой ответ:** _Будут NULL-значения, которые придется чем-то заполнять, а в отдельной таблице их не будет._
* **Интервьюер:** _Пусть стоят NULL. Я про архитектурные сильные и слабые стороны._
* **Мой ответ:** _В отдельной таблице мы можем дописать свои колонки (метаданные связи). А изменение существующей таблицы может поломать старые скрипты `(select *)`._

> **Анализ:** Не смог объяснить почему отдельная join table, может быть лучше отдельной колонки, хотя сам много раз чтобы не загрязнять таблицу дочернюю, добавлял связи через join table, чтобы дочерние таблицы не знали об этой связи, элементарно чтоб по шапке не надавал никто, что в чужую таблицу залез.
> Особенно помню, нужно было привязывать к родовому сертификату, разные типы связей, для роддома(роды), детсткой полеклинники(посещения ребенка), женской консультации(посещения роженици)).
> Уменьшение связанности, делает таблицу переносимой, читаемой, более лёгкой, меньше блокировок при инрсертах, добавляющих связь.

**Материал:** [Выбор стратегии хранения связи: Column vs Join Table](SQL.md#column-join-table-p)

### [SQL] 25:48 Напишите запрос, который выведет имена пользователей, у которых более одной машины. При этом больше ни каких колонок в результирующей выборке быть не должно.

* **Мой ответ:** _Написал вариант с подзапросом через JOIN_

```sql
select u.name
join (select user_id, count(*) from group by id user id) as c on c.user_id = u.user_id
from user u
where c.count > 1
```

* **Интервьюер:** А можно ли без подзапроса? Как это сделать лаконичнее? (HAVING)

```sql
SELECT u.name
FROM users u
JOIN user_car uc ON u.id = uc.user_id
GROUP BY u.id, u.name
HAVING COUNT(uc.car_id) > 1;
```

> **Анализ:** Потратил много времени:
> * Я привык выносить группировки в подзапросы, это дает гибкость, чтобы иметь возможность джойнить результат, как обычную таблицу и выводить любые колонки.
> * При этом, сначало я быстро реализовал вариант с HAVING, но почему-то сработал триггер: чтобы фильтровать по количеству, это количество должно быть в колонках (SELECT).
> * Я забыл, что HAVING может работать напрямую с агрегатной функцией COUNT(), даже если она не выведена в финальный SELECT. Поэтому пытался придумать еще какие-то варианты.

### [SQL] 41:40 Сделали фичу создания пользователя. В БД ID стоит как автоинкремент (IDENTITY/SERIAL). На проде получили ошибку: `user with id 5 already exists`. При этом в базе последний юзер имеет ID = 9. Мы понимаем, что следующий должен быть 10. Почему возникла ошибка?

* **Мой ответ:** _Сбился счетчик._
* **Интервьюер:** _А что за счетчик, можешь рассказать?_
* **Мой ответ:** _Это **Sequence** (последовательность) — специальная структура, которая при каждом инсерте инкрементирует значение. Я не знаю, по какой причине он сбился, но в нем текущее значение осталось 5, хотя должно быть 10._
* **Интервьюер:** _Нужно смоделировать, в результате чего это могло произойти?_
* **Мой ответ:** _Обычно это решается обновлением счетчика по максимальному значению ID юзера в таблице, и дальше он начинает работать правильно, но почему это произошло, я не знаю._
* **Интервьюер:** _А если говорить про сиквенсы, можем ли мы какой-то люфт создавать при создании таблицы, чтобы они были кратны 100, например? Чтобы были "окошки", куда мы могли бы сами что-то забить?_
* **Мой ответ:** _Думаю, можно указать шаг (интервал), чтобы он прибавлял не по 1, а с каким-то интервалом. Технически это делается без проблем._

> **Анализ:** В целом ответил верно, но не указал причину (самая очевидная ручной ввод, с явным указанием ID).

**Материал:** [Работа с последовательностями (Sequences)](SQL.md#sequences-p)


### [SQL] 45:55 Если сравнить суррогатные ключи, два типа данных: UUID против целых чисел (INT/BIGINT). Что вы думаете? Когда уместен один, а когда другой? Как бы вы выбирали, если бы сами создавали базу?

* **Мой ответ**: _Преимуществ UUID не знаю._

> **Анализ**: не работал в распределенных системах, не знаю

**Материал**: [Сравнение суррогатных ключей: BIGINT против UUID](SQL.md#surrogate-key-p)

### [Multithreading] 48:00 Что можешь рассказать о модели памяти JMM, что на твой взгляд ключевое о чем ты сказал бы?

* **Мой ответ:** _Есть хип, в нем живут все объекты джава, но для оптимизации сборки(чистки объектов), хип разделяется еще на дополнительные области, на младшие и старшие покаления. Есть область Eden туда попадают только что созданные, после сборки проверяются используются ли еще, какие не используются очищаются, какие используются попадают в сервивер зону для уплатнения, если объект большой он можешь попасть сразу в старшее поколение OLD и тагже он туда попадает после скольких то переходов туда сюда из сервивер зон._

> **Анализ:** Ушел в описание структуры Heap (Eden/Old). JMM — это правила взаимодействия потоков, а не структура Heap.

**Материал:** [JMM (Java Memory Model)](Multithreading.md#jmm-java-memory-model-p)

### [JVM] 50:00 Какие GC можешь назвать? Какие есть поколения?

* **Мой ответ:** _"Serial, Parallel, CMS, G1."_

> **Анализ:** Назвал классику (Serial, Parallel, CMS, G1). Стоит добавить современные ZGC/Shenandoah и упомянуть, что CMS устарел. Верно описал путь объекта Eden -> Survivor -> Old.

**Материал:** [Виды Garbage Collectors (GC)](JVM.md#gc-type-p)

### [JVM] 50:17 Есть какая-то проблема которую от одной версии к другой решает GC?

* **Мой ответ:** _Хотят уменьшить STW (stop the world) время сборки мусора, чтобы приложение как можно меньше времени останавливалось._

> **Анализ:** Вроде все правильно

**Материал:** [Виды Garbage Collectors (GC)](JVM.md#gc-type-p)

### [JVM] 51:00  Какие области памяти, кроме stack и heap, еще есть в Java?

**Мой ответ:** "Meta inf, но не сказал для чего."

> *Анализ:** Намекали на пулы, но здесь перепутал с **Metaspace**. Там хранятся метаданные классов (имена, методы, поля, константы). Важно: Metaspace находится вне Heap, в Native Memory (оперативной памяти системы).

**Материал:** [Структура памяти JVM](JVM.md#jvm-memory-structure-p)

### [JVM] 51:25 Есть такая штука как пулы в контексте памяти, что можешь о них рассказать? (String Pool)
* **Мой ответ:** _Для оптимизации работы со строками, в хипе еще да, есть стринг пулл. Получается когда строка литералом содается, в кавычках, когда нет её динамического изменения в рантайме, он попадает как бы в стринговый кеш хипа, и затем может переиспользоваться._

> **Анализ:** в целом нормально.

**Материал:** [Структура памяти JVM](JVM.md#jvm-memory-structure-p)

### [JVM] 52:34 А если про какой нибудь инт пул говорить? (Integer Pool)

**Мой ответ:** _Такая же история, тоже нужен для оптимизации, кешируется вроде как +-121 значение, точно не помню. Но в этом диапазоне, если ссылки цифр сравнить, они будут одинаковыми._

> **Анализ:** Перепутал диапазон. Ссылки есть у **объектов-оберток** (`Integer`). Пул кеширует объекты от **-128 до 127**. Когда мы пишем `Integer a = 10;`, происходит *autoboxing*, и берется объект из пула. Обычные примитивы типа int в специальные пулы не выносятся.

**Материал:** [Структура памяти JVM](JVM.md#jvm-memory-structure-p)

### [OOP] 53:00 Если сравнить интерфейсы и абстрактные классы — две похожие штуки — в чем в первую очередь идеологическое отличие у них?

* **Мой ответ:** _Абстрактные классы больше для того, чтобы общий код написать, общую логику, скомпоновать и прописать для всех наследников. Интерфейсы для того, чтобы всякие разные реализации придумывать._
* **Интервьюер:** _А что мне мешает сделать абстрактный класс с 5 абстрактными методами, и все их будут реализовать? Я могу на интерфейсе то же самое сделать, могу на абстрактном классе. В чем отличие?_
* **Мой ответ:** _В абстрактном классе есть ограничение, что ты можешь только от одного класса наследоваться. От интерфейса ты можешь разные поведения добавлять в класс. Если нужно добавить поведение — лучше интерфейсы, а если нужно общий код объединить — абстрактный класс лучше._
* **Интервьюер:** _А если я возьму и в интерфейсе дефолтные методы объявлю (конкретный код)? Будет то же самое, что и абстрактный класс с его методами. В чем тут отличие будет?_
* **Мой ответ:** _Интерфейс не хранит состояние. В абстрактном классе еще можно с состояниями работать._

> *Анализ:** вроде нормальный, бытовой ответ

**Материал:** [Абстрактные классы и Интерфейсы: Фундаментальные отличия](OOP.md#abstract-vs-interfaces-p)

### [Multithreading] 55:46 В системе есть такие сущности как потоки и процесс, в чем между ними разница, особенно в разрезе доступа к ресурсам и оперативной памяти в первую очередь?

* **Мой ответ:** _Процесс — это запущенное приложение, на всю его работу выделяется оперативная память, это разные приложения, они работают изолированно и друг другу не мешают. А потоки уже используют память, выделенную процессору, и она одна общая на все потоки._
* **Интервьюер:** _Я даже уточню: могут ли процессы общаться через оперативную память сообщениями, или потоки? В этом есть разница между ними. То есть один поток поместил что-то в память, второй прочитал. И про процессы: один процесс поместил что-то в память, второй прочитал. Вот тут какие-то нюансы есть._
* **Мой ответ:** _Про процесс не знаю точно, мне кажется, это невозможно._
* **Интервьюер:** _А почему? Есть оперативная память, первый может что-то записать туда, второй прочитать. Ни Корбой (CORBA), ни базой данных, ни файлами?_
* **Мой ответ:** _Нет, не объясню, почему он не сможет прочитать._

> **Анализ:** Интервьюер копал в сторону **Виртуальной памяти**. На физическом уровне (в ОЗУ) данные процессов могут лежать рядом, но ОС выдает каждому процессу свои **виртуальные адреса**. Процесс "заперт" в своей карте памяти и физически не знает, где лежат данные соседа. Это сделано для **безопасности** (чтобы одно приложение не могло прочитать пароли или баланс другого).

**Материал:** [Процесс и Поток: Основы ОС](Multithreading.md#process-p)

### [JVM] 58:20 С профилировщиками приходилось сталкиваться? (JDK Tools)

* **Мой ответ:** _Visual VM, из jdk инструмент: jmap, jstack, jstat._

> **Анализ**:**Назвал отличные консольные утилиты. Для Middle-позиции стоит добавить **JFR (Java Flight Recorder)** — это стандарт индустрии для продакшена.

**Материал:** [Диагностика и профилирование](JVM.md#profiling-p)

### [JVM] 58:48 На какие виды делятся профилировщики?

* **Мой ответ:** _Не знаю._

> **Анализ:** Ключевое деление: **Сэмплирующие (Sampling)** — делают "снимки" стека через интервалы (быстрые, мало нагружают) и **Инструментирующие (Instrumenting)** — внедряют код в методы для замера каждого вызова (точные, но сильно тормозят приложение).

**Материал:** [Диагностика и профилирование](JVM.md#profiling-p)

### [Spring] 59:00 Разница между Spring и Spring Boot и кто сначала появился?

* **Мой ответ:** _Сначала появился Spring Framework. Spring Boot — это надстройка. Весь прикол в стартерах (готовых конфигурациях модулей) и автоматической конфигурации. Также встроенный сервер Tomcat._
* **Интервьюер:** _А в Spring Boot веб-сервер это обязательная составляющая?_
* **Мой ответ:** _Можно отключить, но по умолчанию он подтягивается._
* **Интервьюер:** _А как его отключить можно?_
* **Мой ответ:** _Через конфигурацию, какая-то настройка, не помню точно._

> **Анализ:** Не вспомнил как отключается сервер:
>  * Через настройки: `spring.main.web-application-type=none` в `application.properties`.
>  * Исключением зависимости (например, убрать `spring-boot-starter-web`).

**Материал:** [Spring Boot](Spring.md#boot-p)

### [Spring] 1:00 Есть аннотация @Transactional, в разрезе доступа к данным, можешь рассказать за что она отвечает и в идеале как она под капотом работает?

*   **Мой ответ:** _Метод, помеченный этой аннотацией — для него создается прокси, и он уже перехватывает вызов этого метода и добавляет возможности Hibernate: сессию создает, открывает коммит, закрывает, сущность помещается в Persistence Context, запросы отложенные, у Lazy-объектов в сущности появляется сессия, подставляется._
*   **Интервьюер:** _А если кейс: есть класс, в нем два метода, один помечен как Transactional, другой нет, и я из того, который НЕ помечен, вызываю тот, который помечен. То есть метод А и Б, метод А чистый, метод Б — Transactional, я из А вызываю Б. Есть какие-то особенности работы при этом у Transactional?_
*   **Мой ответ:** _Да, вызов будет не через прокси, и все вот эти плюшки хибернетовские не будут добавлены, Spring-транзакция не откроется._
*   **Интервьюер:** _А как сделать так, чтобы вызовы, без разницы откуда, шли именно к прокси, а не к объекту? В какой момент мы получаем прокси, а в какой сам объект? То есть я даже уточню вопрос: вот у нас есть класс, вот он висит в памяти замечательно, и также у нас где-то висит этот прокси, допустим, и в какой момент Спринг выдает именно прокси? Как архитектурно обращаться именно к прокси, когда мы его получаем?_
*   **Мой ответ:** _В Спринге все объекты живут в контейнере, бинами называются. В момент создания они проходят по определенному этапу, и после создания объекта начинается создание прокси. В контейнер помещается не реальный объект, а его подмена, и мы из контейнера берем эту подмену и работаем с ней. А если мы создали просто объект сами, то он жизненный цикл не прошел, под него не создались все аспекты, и он уже будет выполнять метод без этой сквозной логики._
*   **Интервьюер:** _А как я могу в любой момент получить именно проксю, а не объект?_
*   **Мой ответ:** _Уточню, проксю — вы имеете в виду бин? Есть способы через поле @Autowired, например._
*   **Интервьюер:** _А без автовайреда, прямо в методе каком-то?_
*   **Мой ответ:** _Через ApplicationContext вставить и через него получить._

> **Анализ:** Интервьюер хотел услышать четкое разделение между `this` и `Proxy`. Слово **`this`** само по себе означает вызов у реального объекта «напрямую», минуя обертку. Реальный объект («таргет») лежит внутри прокси в качестве свойства. Когда мы берем бин из контекста — мы берем прокси.

**Материал:** [Transactional](Spring.md#transactional-p)

### [REST] 01:06 Если допустим говорить про уровни зрелости REST, что можешь рассказать?

* **Мой ответ:** _Я знаю 6 принципов RESTful, а чтоб по уровням — что-то не слышал._
* **Интервьюер:** _Ну ок, что за принципы RESTful, можешь тогда о них рассказать?_
* **Мой ответ:** _Чтобы приложение считалось в стиле RESTful, нужно соблюдение 6 принципов: 1. Stateless (без состояния); 2. Единый интерфейс; 3. Клиент-серверное взаимодействие; 4. Слойная архитектура; 5. Код по требованию; 6. Кэширование._

> **Анализ:** Интервьюер ждал перехода от общих принципов (теории Филдинга) к конкретной практике — **Модели Ричардсона**. Нужно знать, что Уровень 0 — это "туннель" (один URL на всё), Уровень 1 — появление ресурсов (разные URL), Уровень 2 — использование глаголов HTTP и статус-кодов, Уровень 3 — HATEOAS (ссылки в ответах).

**Материал:** [Шесть принципов REST (Рой Филдинг)](REST.md#rest-principles-p)

### [REST] 01:07 Представим, что мы хотим написать простенький интернет-магазин. Есть сущность заказа — Order. Как будут выглядеть основные урлы: создание заказа, перемещение заказа в отдел отправки, удаление заказа, изменение? Тип запроса, урл и т.д., просто проговорить вслух.

* **Мой ответ:** _REST в основе подразумевает использование HTTP протокола, в частности это значит, что должны использоваться методы этого протокола, чтобы они ложились на CRUD операции. То есть GET на получение, POST на создание, PUT на изменение, PATCH на частичное изменение._
* **Интервьюер:** _Меня даже конкретные урлы под эту задачу интересуют, не просто принципы. Нам нужно создать конкретно заказ, как будет выглядеть URL?_
* **Мой ответ:** _`/orders` метод POST._
* **Интервьюер:** _Если нужно изменить какую-то позицию в заказе?_
* **Мой ответ:** _Добавляется параметр PathVariable..._
* **Интервьюер:** _Перефразирую: мы хотим изменить заказ полностью, было 5 позиций, мы хотим изменить их все._
* **Мой ответ:** _Метод PUT, `/orders/{id}`._
* **Интервьюер:** _А если какую-то одну позицию хотим?_
* **Мой ответ:** _PATCH._
* **Интервьюер:** _Если бы в нем было три свойства, мы хотим изменить только одно, мы что будем в бади передавать используя PATCH? Все или один какой-то?_
* **Мой ответ:** _То, что конкретно хочешь изменить, ты должен передавать. Если тебе не нужны оставшиеся поля, скорее всего, их нельзя передавать._
* **Интервьюер:** _А если мы передали только одно, остальные на входе условно будут как null. Если есть какое-то значение — мы его обновляем, если пришел null — мы его не трогаем. А если мы одно из них хотим именно в null выставить, стереть? В чем отличие игнорирования от стирания при PATCH, как решать эту проблему?_
* **Мой ответ:** _Не знаю._

> **Анализ:** Не сразу понял вопрос. Вместо того чтобы сразу приступить к практическому проектированию URL, начал объяснять общую теорию REST. Забыл, что URL должен содержать префикс и версию: `POST /api/v1/orders`. Имя ресурса всегда во множественном числе, а данные передаются в теле (body). Не смог четко ответить, что в PATCH — передаем только то поле, которое меняем, а остальные на обычно фильтруются проверкой `if (field != null)`. Не смог объяснить, как в PATCH игнорировать фильтр на `null`, если нужно именно стереть (обнулить) значение в БД: обновить через put целиком или передавать значения поля в мапе с признаком обнуления.

**Материал:** [Практика проектирования REST API](REST.md#design-practice-p), [Модель зрелости Ричардсона](REST.md#maturity-model-p)

### [Spring] 01:14 Есть API на создание заказа на работу с ордерем и сейчас получать get orders и post orders может кто угодно, просто контроллер и репозиторий внутри и больше ничего. И нам надо сделать так чтобы в одну api создавать мог пользователь с одной ролью, а смотреть пользователь с другой, создает только покупатель, а смотрит только менеджер. Что нам нужно сделать в проекте чтобы такая ролевая модель заработала?

* **Мой ответ:** _Добавляется секьюрити фреймворк, он добавляет фильтры через которые запрос проходит, авторизация в том числе. Настраивается при помощи HttpSecurity, в нем можно прописать настройки, какие запросы мы хотим чтобы фильтровались, были возможны только для конкретного пользователя._
* **Интервьюер:** _А что нам надо, вот мы подключили Security, что то еще создать какие-то файлы, как то настроить, ну вот есть конкретный метод контроллера, что внего может только бальзак с одной, ролью попасть, а во второй метод только пользователь с другой ролью. представим что у нас jwt токен, нам ни надо хранить ни роли, ни чего у нас в базе, максимально упрощенная модель будет. То-есть бальзак запрос пришел, сразу в токене указана какая роль, что нужно сделать на низком уровне?_
* **Мой ответ:** _Если авторизация через jwt токен, все роли в нем хранятся, он должен как-то извлечься из запроса, затем извлечься роли. Я с ролями и jwt токеном не работал._

> **Анализ:** Опять меня попросили конкретный пример, а я рассказал базу. Интервьюер ждал понимания механики «под капотом»: создание конфигурационного бина `SecurityFilterChain` и использование `@PreAuthorize` над методами. Я не работал с JWT на практике и не до конца понимал, что в Stateless-режиме проверка идет через **валидацию подписи токена секретным ключом**. Сервер не идет в базу, он вычисляет хеш и, если подпись совпала, доверяет ролям из токена.

**Материал:** [Spring Security](Spring.md#security-p)

### [Spring] 01:17 Есть API findAll, которое возвращает заказы. Сначала их было 10, потом 100, потом 1000 — фронтенд их нормально отображал. Но когда записей стало 1 000 000, фронт начал тормозить. Что делать, как решать проблему?

* **Мой ответ**: _Использовать пагинацию._
* **Интервьюер**: _А какая-то встроенная поддержка пагинации в Spring есть?_
* **Мой ответ**: _Да._
* **Интервьюер**: _Можешь описать, какая примерно? Может, какие-то классы вспомнишь, куда передавать, любые детали?_
* **Мой ответ**: _Аннотация какая-то... В наш метод эндпоинта прилетает «пагинатор», он внедряется Спрингом, и мы можем его просто в запрос подставить, и он уже сам скачивает нужные записи, используя Offset и Limit._

> **Анализ:** Я правильно назвал принцип, но плавал в названиях классов. В методе контроллера, интерфейс **`Pageable`** принимает параметры (номер страницы, размер, сортировка). Далее передается в метод Spring Data. Интерфейс **`Page`** возвращает не только список, но и метаданные (общее количество записей/страниц).

**Материал:** [Пагинация](Spring.md#pagination-p)

### [Spring] 01:19 Нам нужно фильтровать данные по множеству полей (например, 50 фильтров), которые могут комбинироваться. Как это реализовать?

* **Мой ответ:** _Есть специальный класс, он позволяет динамически задавать эти поля, можно условия задавать, как проверять. Как он называется — я забыл. Вообщем есть возможность динамически настраивать фильтр для запроса, чтобы null-значения игнорировались._

> **Анализ:** Я правильно вспомнил концепцию, но забыл ключевые термины.
Интервьюер проверял умение избегать "комбинаторного взрыва" методов в репозитории. Если писать `findBy...` на каждое поле, поддержка кода станет невозможной. Даже 50 `if` в сервисе — это плохой тон (Boilerplate).
Важно понимать, как приходят данные. Если поля фиксированы в таблице и не планируют расширяться — подойдет **Specification** для добавления предикатов по условию. Если свойства динамические, то можно использовать `Map` (ключ-значение) + EAV и добавлять предикаты в цикле.
Для таких задач часто используют Elasticsearch или MongoDB, так как они созданы для гибких схем. Но если мы остаемся в рамках SQL, нам нужно архитектурное решение.
В своем проекте я использовал EAV модель для хранения динамических характеристик товаров без изменения структуры таблиц.

**Материал:** [Динамические фильтры](Spring.md#filtering-p)

### [SQL] 1.20 Что можешь про EXPLAIN рассказать?

* **Мой ответ:** _Можно посмотреть план выполнения запроса и какие индексы используются. Если запрос медленный — первым делом вызываем EXPLAIN. EXPLAIN строит план по статистике, а ANALYZE реально выполняет запрос._
* **Интервьюер:** _А что в EXPLAIN будет привлекать внимание? Что глаз будет искать в первую очередь?_
* **Мой ответ:** _Cost (стоимость), время выполнения, используются ли индексы._
* **Интервьюер:** _А как мы поймем, используются ли индексы? Если запрос большой, что искать через Ctrl+F, на что "возбудиться", что идет не так?_
* **Мой ответ:** _(Здесь нужно было назвать типы сканирования)._

> **Анализ:** Ответ правильный по сути, но не хватило "ключевых слов", которые ищет глаз разработчика в плане.
>  * **Что искать (Ctrl+F):**
>  * **Seq Scan** (Sequential Scan) — это ПЛОХО. Это значит, что БД читает всю таблицу целиком, пропуская индексы. Именно это мы ищем, чтобы "возбудиться".
>  * **Index Scan** / **Index Only Scan** — это ХОРОШО. БД использует индекс.
>  * **Cost и Actual Time:** Мы смотрим на узлы с самым большим `actual time` — это "узкие места".

**Материал:** [Оптимизация запросов: EXPLAIN](SQL.md#explain-p)