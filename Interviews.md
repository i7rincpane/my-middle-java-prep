# Собеседования
* ### [Инжиниринговый холдинг «эВ-групп»](#Инжиниринговый-холдинг-эВ-групп)

## Инжиниринговый холдинг «эВ-групп»
*Дата: 20 января 2026 | Позиция: Java Middle*

`#SQL` `#Hibernate`  `#Multithreading` `#JavaCore && OOP` `#JVM` `#Spring` `#REST`

### [SQL] 05:35  Снизу представлена наша БД в которой представлено 2 таблицы (User и car). Мы знаем что автомобили принадлежат этим пользователям, но у нас нигде это не написано. Нам нужно давать возможность записывать какой автомобиль кому принадлежит. Задача: У пользователей может быть много автомобилей, но у автомобиля может быть только один пользователь. Вы можете делать все что угодно, создавать таблицы или изменять существующие.
* **Мой ответ:** В таблице машина нужен внешний ключ Foreign Key на таблицу юзера, кому какая машина принадлежит.
* **Интервьюер:** А как бы вы назвали его?
* **Мой ответ:** user_id.
* **Интервьюер:** А кроме этого варианта еще какие-то есть, если по какой-то причине нам не подходит вариант с колонкой? Например у нас нет прав на изменение таблиц.
* **Мой ответ:** Создать отдельную таблицу и там прописать связи user_id и car_id.
* **Интервьюер:** Как бы назвали таблицу?
* **Мой ответ:** user_car.
* **Интервьюер:** Колонки перечислите какие добавите.
* **Мой ответ:** user_id и car_id и еще идентификатор id, можно его добавить, можно составной ключ использовать.
* **Интервьюер:** А в каком случае вы бы использовали составной, а в каком создали бы id суррогатный? В данном случае какой вариант более уместен?
* **Мой ответ:** Из плюсов — удобнее по id обращаться, искать сразу записи. Из минусов — лишняя колонка появилась. (Анализ: тут я поплыл, начал говорить поверхностно).
* **Интервьюер:** То есть есть подход когда люди не задумываясь везде ставят суррогатный ключ, иногда у них спросишь зачем почему?
* **Мой ответ:** Чтобы проще было добраться до строки...
* **Интервьюер:** Какие будут основные запросы к этой таблице, user_car, русским языком.
* **Мой ответ:** Машины для пользователя, какие у него есть.
* **Интервьюер:** Ну либо по машине, какой пользователь у нее есть, то есть нам суррогатный ид даже не понадобится, мы будем выборки постоянно либо по одному либо по другому ключу.
* **Мой ответ:** Да, возможно.
* **Анализ:** Не смог внятно объяснить преимущество составного ключа в связочной таблице. В связочной таблице суррогатный `id` часто избыточен и просто занимает место на диске, так как поиск всегда идет по `user_id` или `car_id`.
* Вспомнил мой рабочий пример: идентификаторы записей постоянно удалялись и пересоздавались логикой приложения. При использовании суррогатных ID это приводило к тому, что я не мог идентифицировать уже существующую связь, считал её новой и плодил дубликаты. Использование натуральной связки (бизнес-полей) на уровне составного Primary Key позволило БД самой отсекать дубли и гарантировать уникальность, даже если технические ID объектов постоянно менялись.
* **Материал:** [Классификация первичных ключей (Primary Keys)](SQL.md#Классификация-первичных-ключей-Primary-Keys)

### [Hibernate] 11:30 Вы сказали, что есть нюансы работы с суррогатным ID в Hibernate. Можете проговорить этот момент?
* **Мой ответ:** Помню, какая-то сложность есть при реализации связи «один-к-одному», когда нужно выбирать суррогатный или составной ключ, что именно — не помню.
* **Интервьюер:** В каком случае нам будет обязателен именно суррогатный ключ? Или он всегда обязателен? Для чего вообще используется ключ в Hibernate?
* **Мой ответ:** Не помню, работал давно, была какая-то проблема.
* **Анализ:** Зациклился на «проблемах» в Hibernate связанных с ключами, пропустил остальные вопросы, на которые мог бы ответить. Стоило хотя бы сказать, что составной ключ не генерируется базой автоматически и требует ручного добавления при сохранении и создания отдельного класса.
Если бы вовремя очнулся, сказал бы, что суррогатный ключ **не обязателен**, обязателен сам идентификатор (любого типа: натуральный, составной или суррогатный). Без @Id проект не скомпилируется, так как JPA спецификация требует наличия первичного ключа для каждой сущности.
* **Материал:** [Работа Hibernate с ключами и контекстом](Hibernate.md#Работа-Hibernate-с-ключами-и-контекстом)

### [SQL] 13:02 А кроме суррогатных первичных ключей, еще какие бывают?
* **Мой ответ:** Ну, составной мы проговорили. 
* **Интервьюер:** А натуральный первичный ключ — это про что история?
* **Мой ответ:** По какой-то колонке, он не генерируется... по имени, например. 
* **Интервьюер:** В данном случае (в таблице user_car) у нас ID суррогатный, а user_id какой будет?
* **Мой ответ:** Натуральный. (Анализ: Угадал, так как продолжал думать, что натуральный — это просто "самописный", содержащий бизнес-информацию, а не просто подставляемый извне).
* **Анализ:** У меня слились определения составных и натуральных ключей. Понимаю что, суррогатный ключ — это "синтетика" (1, 2, 3), созданная только для БД, а натуральный ключ — это данные, которые существуют сами по себе (Email). Но внешний ключ user_id, вызвал у меня ступор, он вроде как не сгенерировался, просто подставился, и при этом это бессмысленный идендификатор, который сам по себе ни какой информации не несет.
Получается что, в таблице связей `user_car` поля `user_id` и `car_id` являются натуральными, так как они ссылаются на уже существующие сущности. Если мы объединяем их в один ключ — он становится **составным натуральным ключом**.
* **Материал:** [Классификация первичных ключей (Primary Keys)](SQL.md#Классификация-первичных-ключей-Primary-Keys)

### [SQL] 14:36 У нас одна машина может принадлежать только одному человеку, а у человека может быть много машин. Отдельная таблица — это по сути заготовка под Many-to-Many. Как сделать так, чтобы одной машине нельзя было дать двух собственников?
* **Мой ответ**: Констрейнт UNIQUE написать на связку (user_id, car_id).
* **Интервьюер**: Мы тогда не сможем задублировать именно связку (ту же машину тому же человеку), но одну машину мы сможем дать десяти разным людям спокойно.
* **Анализ:** долго рассуждал, думал о сложных CHECK-констрейнтах, связывающих таблицы. Основная ошибка, что воспринял промежуточную таблицу как жесткий паттерн для Many-to-Many. В итоге с подсказкой дошел, что достаточно просто запретить дублирование в колонке car_id.
* **Материал:** [Классификация первичных ключей (Primary Keys)](SQL.md#Управление-типом-связи-через-ограничения-Constraints)

### [SQL] 18:01 Если мы делаем составной первичный ключ на наши поля (user_id, car_id), нужен ли нам дополнительно составной констрейнт уникальности по этим же двум колонкам?
* **Мой ответ:** Если мы делаем ключ первичным, то база автоматически добавляет ограничение уникальности. Поэтому прописывать его еще раз отдельно не нужно.
* **Анализ:** вроде правильно
* **Материал:** [Классификация первичных ключей (Primary Keys)](SQL.md#Управление-типом-связи-через-ограничения-Constraints)

### [SQL] 21:16 Сравним подходы: когда мы добавляем колонку (FK), а когда — отдельную таблицу связок? Вариант с колонкой проще, "из коробки". Какие минусы у колонки и сильные стороны у связочной таблицы? Когда таблица уместнее, даже если мы админы базы?
* **Мой ответ:** Когда нет прав на изменение основной таблицы.
* **Интервьюер:** Права не проблема.
* **Мой ответ:** Будут NULL-значения, которые придется чем-то заполнять, а в отдельной таблице их не будет.
* **Интервьюер:** Пусть стоят NULL. Я про архитектурные сильные и слабые стороны.
* **Мой ответ:** В отдельной таблице мы можем дописать свои колонки (метаданные связи). А изменение существующей таблицы может поломать старые скрипты `(select *)`.
* **Анализ:** Я был прав насчет NULL. Если у 1 млн пользователей машина есть только у 100, то колонка `car_id` будет на 99.9% пустой. Это неэффективно: таблица "пухнет", индексы по этой колонке становятся тяжелыми и медленными.
* Но стоило еще сказать про возможность переноса таблицы, шардирования, изоляция(меньше блокировок), пересоздание индекса при записи, и сложность чтения с дополнительным join на связующую таблицу. 
* **Материал:** [Выбор-стратегии-хранения-связи-Column-vs-Join-Table](SQL.md#Выбор-стратегии-хранения-связи-Column-vs-Join-Table)

### [SQL] 25:48 Напишите запрос, который выведет имена пользователей, у которых более одной машины. При этом больше ни каких колонок в результирующей выборке быть не должно.
* **Мой ответ:** Написал вариант с подзапросом через JOIN
```sql
select u.name
from user u
join (select user_id, count(*) from group by id user id) as c on c.user_id = u.user_id
where c.count > 1
```
* **Интервьюер:** А можно ли без подзапроса? Как это сделать лаконичнее? (HAVING)

```sql
SELECT u.name
FROM users u
JOIN user_car uc ON u.id = uc.user_id
GROUP BY u.id, u.name
HAVING COUNT(uc.car_id) > 1;
```
* **Анализ:** Потратил много времени:
* Я привык выносить группировки в подзапросы, это дает гибкость, чтобы иметь возможность джойнить результат, как обычную таблицу и выводить любые колонки.
* При этом, сначало я быстро реализовал вариант с HAVING, но почему-то сработал триггер: чтобы фильтровать по количеству, это количество должно быть в колонках (SELECT).
* Я забыл, что HAVING может работать напрямую с агрегатной функцией COUNT(), даже если она не выведена в финальный SELECT. Поэтому пытался придумать еще какие-то варианты.

### [SQL] 41:40 Сделали фичу создания пользователя. В БД ID стоит как автоинкремент (IDENTITY/SERIAL). На проде получили ошибку: `user with id 5 already exists`. При этом в базе последний юзер имеет ID = 9. Мы понимаем, что следующий должен быть 10. Почему возникла ошибка?
* **Мой ответ:** Сбился счетчик.
* **Интервьюер:** А что за счетчик, можешь рассказать?
* **Мой ответ:** Это **Sequence** (последовательность) — специальная структура, которая при каждом инсерте инкрементирует значение. Я не знаю, по какой причине он сбился, но в нем текущее значение осталось 5, хотя должно быть 10.
* **Интервьюер:** Нужно смоделировать, в результате чего это могло произойти?
* **Мой ответ:** Обычно это решается обновлением счетчика по максимальному значению ID юзера в таблице, и дальше он начинает работать правильно, но почему это произошло, я не знаю.
* **Интервьюер:** А если говорить про сиквенсы, можем ли мы какой-то люфт создавать при создании таблицы, чтобы они были кратны 100, например? Чтобы были "окошки", куда мы могли бы сами что-то забить?
* **Мой ответ:** Думаю, можно указать шаг (интервал), чтобы он прибавлял не по 1, а с каким-то интервалом. Технически это делается без проблем.
* **Анализ:** В целом ответил верно, но не указал причину (самая очевидная ручной ввод, с явным указанием ID).
* **Материал:** [Работа с последовательностями (Sequences)](SQL.md#работа-с-последовательностями-Sequences)


### [SQL] 45:55 Если сравнить суррогатные ключи, два типа данных: UUID против целых чисел (INT/BIGINT). Что вы думаете? Когда уместен один, а когда другой? Как бы вы выбирали, если бы сами создавали базу?
* **Мой ответ**: Преимуществ UUID не знаю.
* **Анализ**: не работал в распределенных системах, не знаю
* **Материал**: [Сравнение суррогатных ключей: BIGINT против UUID](SQL#Сравнение-суррогатных-ключей-BIGINT-против-UUID)

### [Multithreading] 48:00 Что можешь рассказать о модели памяти JMM, что на твой взгляд ключевое о чем ты сказал бы?
* **Мой ответ:** "Есть хип, в нем живут все объекты джава, но для оптимизации сборки(чистки объектов), хип разделяется еще на дополнительные области, на младшие и старшие покаления. Есть область Eden туда попадают только что созданные, после сборки проверяются используются ли еще, какие не используются очищаются, какие используются попадают в сервивер зону для уплатнения, если объект большой он можешь попасть сразу в старшее поколение OLD и тагже он туда попадает после скольких то переходов туда сюда из сервивер зон"
* **Анализ:** Ушел в описание структуры Heap (Eden/Old). JMM — это правила взаимодействия потоков, а не структура Heap.
* **Материал:** [JMM (Java Memory Model)](Multithreading.md#jmm-java-memory-model)

### [JVM] 50:00 Какие GC можешь назвать? Какие есть поколения?
* **Мой ответ:** "Serial, Parallel, CMS, G1."
* **Анализ:** Назвал классику (Serial, Parallel, CMS, G1). Стоит добавить современные ZGC/Shenandoah и упомянуть, что CMS устарел. Верно описал путь объекта Eden -> Survivor -> Old.
* **Материал:** [Виды и работа GC](JVM.md#виды-garbage-collectors-gc-и-их-алгоритмы)

### [JVM] 50:17 Есть какая-то проблема которую от одной версии к другой решает GC?
* **Мой ответ:** "Хотят уменьшить STW (stop the world) время сборки мусора, чтобы приложение как можно меньше времени останавливалось."
* **Анализ:** Вроде все правильно
* **Материал:** [Проблема STW и оптимизации](JVM.md#виды-garbage-collectors-gc-и-их-алгоритмы)

### [JVM] 51:00  Какие области памяти, кроме stack и heap, еще есть в Java?
* **Мой ответ:** "Meta inf, но не сказал для чего."
* **Анализ:** Намекали на пулы, но здесь перепутал с **Metaspace**. Там хранятся метаданные классов (имена, методы, поля, константы). Важно: Metaspace находится вне Heap, в Native Memory (оперативной памяти системы).
* **Материал:** [Структура памяти JVM](JVM.md#структура-памяти-jvm-java-virtual-machine)

### [JVM] 51:25 Есть такая штука как пулы в контексте памяти, что можешь о них рассказать? (String Pool)
* **Мой ответ:** "Для оптимизации работы со строками, в хипе еще да, есть стринг пулл. Получается когда строка литералом содается, в кавычках, когда нет её динамического изменения в рантайме, он попадает как бы в стринговый кеш хипа, и затем может переиспользоваться."
* **Анализ:** в целом нормально.
* **Материал:** [String Pool и интернирование](JVM.md#структура-памяти-jvm-java-virtual-machine)

### [JVM] 52:34 А если про какой нибудь инт пул говорить? (Integer Pool)
* **Мой ответ:** "Такая же история, тоже нужен для оптимизации, кешируется вроде как +-121 значение, точно не помню. Но в этом диапазоне, если ссылки цифр сравнить, они будут одинаковыми."
* **Анализ:** Перепутал диапазон. Ссылки есть у **объектов-оберток** (`Integer`). Пул кеширует объекты от **-128 до 127**. Когда мы пишем `Integer a = 10;`, происходит *autoboxing*, и берется объект из пула. Обычные примитивы типа int в специальные пулы не выносятся.
* **Материал:** [Integer Pool](JVM.md#структура-памяти-jvm-java-virtual-machine)

### [JavaCore && OOP] 53:00 Если сравнить интерфейсы и абстрактные классы — две похожие штуки — в чем в первую очередь идеологическое отличие у них?
* **Мой ответ:** Абстрактные классы больше для того, чтобы общий код написать, общую логику, скомпоновать и прописать для всех наследников. Интерфейсы для того, чтобы всякие разные реализации придумывать.
* **Интервьюер:** А что мне мешает сделать абстрактный класс с 5 абстрактными методами, и все их будут реализовать? Я могу на интерфейсе то же самое сделать, могу на абстрактном классе. В чем отличие?
* **Мой ответ:** В абстрактном классе есть ограничение, что ты можешь только от одного класса наследоваться. От интерфейса ты можешь разные поведения добавлять в класс. Если нужно добавить поведение — лучше интерфейсы, а если нужно общий код объединить — абстрактный класс лучше.
* **Интервьюер:** А если я возьму и в интерфейсе дефолтные методы объявлю (конкретный код)? Будет то же самое, что и абстрактный класс с его методами. В чем тут отличие будет?
* **Мой ответ:** Интерфейс не хранит состояние. В абстрактном классе еще можно с состояниями работать.
* **Анализ:** вроде нормальный, бытовой ответ
* **Материал:** [Абстрактные-классы-и-Интерфейсы-Фундаментальные-отличия](JavaCore.md#Абстрактные-классы-и-Интерфейсы-Фундаментальные-отличия)

### [Multithreading] 55:46 В системе есть такие сущности как потоки и процесс, в чем между ними разница, особенно в разрезе доступа к ресурсам и оперативной памяти в первую очередь?
* **Мой ответ:** Процесс — это запущенное приложение, на всю его работу выделяется оперативная память, это разные приложения, они работают изолированно и друг другу не мешают. А потоки уже используют память, выделенную процессору, и она одна общая на все потоки.
* **Интервьюер:** Я даже уточню: могут ли процессы общаться через оперативную память сообщениями, или потоки? В этом есть разница между ними. То есть один поток поместил что-то в память, второй прочитал. И про процессы: один процесс поместил что-то в память, второй прочитал. Вот тут какие-то нюансы есть.
* **Мой ответ (с сомнениями):** Про процесс не знаю точно, мне кажется, это невозможно.
* **Интервьюер:** А почему? Есть оперативная память, первый может что-то записать туда, второй прочитать. Ни Корбой (CORBA), ни базой данных, ни файлами?
* **Мой ответ:** Нет, не объясню, почему он не сможет прочитать.
* **Анализ:** Интервьюер копал в сторону **Виртуальной памяти**. На физическом уровне (в ОЗУ) данные процессов могут лежать рядом, но ОС выдает каждому процессу свои **виртуальные адреса**. Процесс "заперт" в своей карте памяти и физически не знает, где лежат данные соседа. Это сделано для **безопасности** (чтобы одно приложение не могло прочитать пароли или баланс другого).
* **Материал:** [Процесс и Поток: Основы ОС](Multithreading.md#процесс-и-поток-основы-ос)

### [JVM] 58:20 С профилировщиками приходилось сталкиваться? (JDK Tools)
* **Мой ответ:** "Visual VM, из jdk инструмент: jmap, jstack, jstat."
* **Анализ**:**Назвал отличные консольные утилиты. Для Middle-позиции стоит добавить **JFR (Java Flight Recorder)** — это стандарт индустрии для продакшена.
* **Материал:** [Инструменты профилирования](JVM.md#диагностика-и-профилирование)

### [JVM] 58:48 На какие виды делятся профилировщики?
* **Мой ответ:** "Не знаю."
* **Анализ:** Ключевое деление: **Сэмплирующие (Sampling)** — делают "снимки" стека через интервалы (быстрые, мало нагружают) и **Инструментирующие (Instrumenting)** — внедряют код в методы для замера каждого вызова (точные, но сильно тормозят приложение).
* **Материал:** [Виды профилировщиков](JVM.md#диагностика-и-профилирование)

### [Spring] 59:00 Разница между Spring и Spring Boot и кто сначала появился?

* **Мой ответ:** Сначала появился Spring Framework. Spring Boot — это надстройка. Весь прикол в стартерах (готовых конфигурациях модулей) и автоматической конфигурации. Также встроенный сервер Tomcat.
* **Интервьюер:** А в Spring Boot веб-сервер это обязательная составляющая?
* **Мой ответ:** Можно отключить, но по умолчанию он подтягивается.
* **Интервьюер:** А как его отключить можно?
* **Мой ответ:** Через конфигурацию, какая-то настройка, не помню точно.
* **Анализ:** Не вспомнил как отключается сервер:
  * Через настройки: `spring.main.web-application-type=none` в `application.properties`.
  * Исключением зависимости (например, убрать `spring-boot-starter-web`).
* **Материал:** [Spring vs Spring Boot](Spring.md#spring-framework-vs-spring-boot)

### [Spring] 1:00 Есть аннотация @Transactional, в разрезе доступа к данным, можешь рассказать за что она отвечает и в идеале как она под капотом работает?
*   **Мой ответ:** Метод, помеченный этой аннотацией — для него создается прокси, и он уже перехватывает вызов этого метода и добавляет возможности Hibernate: сессию создает, открывает коммит, закрывает, сущность помещается в Persistence Context, запросы отложенные, у Lazy-объектов в сущности появляется сессия, подставляется.
*   **Интервьюер:** А если кейс: есть класс, в нем два метода, один помечен как Transactional, другой нет, и я из того, который НЕ помечен, вызываю тот, который помечен. То есть метод А и Б, метод А чистый, метод Б — Transactional, я из А вызываю Б. Есть какие-то особенности работы при этом у Transactional?
*   **Мой ответ:** Да, вызов будет не через прокси, и все вот эти плюшки хибернетовские не будут добавлены, Spring-транзакция не откроется.
*   **Интервьюер:** А как сделать так, чтобы вызовы, без разницы откуда, шли именно к прокси, а не к объекту? В какой момент мы получаем прокси, а в какой сам объект? То есть я даже уточню вопрос: вот у нас есть класс, вот он висит в памяти замечательно, и также у нас где-то висит этот прокси, допустим, и в какой момент Спринг выдает именно прокси? Как архитектурно обращаться именно к прокси, когда мы его получаем?
*   **Мой ответ:** В Спринге все объекты живут в контейнере, бинами называются. В момент создания они проходят по определенному этапу, и после создания объекта начинается создание прокси. В контейнер помещается не реальный объект, а его подмена, и мы из контейнера берем эту подмену и работаем с ней. А если мы создали просто объект сами, то он жизненный цикл не прошел, под него не создались все аспекты, и он уже будет выполнять метод без этой сквозной логики.
*   **Интервьюер:** А как я могу в любой момент получить именно проксю, а не объект?
*   **Мой ответ:** Уточню, проксю — вы имеете в виду бин? Есть способы через поле @Autowired, например.
*   **Интервьюер:** А без автовайреда, прямо в методе каком-то?
*   **Мой ответ:** Через ApplicationContext вставить и через него получить.
* **Анализ:** Интервьюер хотел услышать четкое разделение между `this` и `Proxy`. Слово **`this`** само по себе означает вызов у реального объекта «напрямую», минуя обертку.
Реальный объект («таргет») лежит внутри прокси в качестве свойства. Когда мы берем бин из контекста — мы берем прокси.
* **Материал:** [Spring: Proxy и Жизненный цикл бина](Spring.md#transactional-и-механизмы-проксирования)

### [REST] 01:06 Если допустим говорить про уровни зрелости REST, что можешь рассказать?
* **Мой ответ:** Я знаю 6 принципов RESTful, а чтоб по уровням — что-то не слышал.
* **Интервьюер:** Ну ок, что за принципы RESTful, можешь тогда о них рассказать?
* **Мой ответ:** Чтобы приложение считалось в стиле RESTful, нужно соблюдение 6 принципов: 1. Stateless (без состояния); 2. Единый интерфейс; 3. Клиент-серверное взаимодействие; 4. Слойная архитектура; 5. Код по требованию; 6. Кэширование.
* **Анализ:** Интервьюер ждал перехода от общих принципов (теории Филдинга) к конкретной практике — **Модели Ричардсона**. Нужно знать, что Уровень 0 — это "туннель" (один URL на всё), Уровень 1 — появление ресурсов (разные URL), Уровень 2 — использование глаголов HTTP и статус-кодов, Уровень 3 — HATEOAS (ссылки в ответах).
* **Материал:** [Определение и уровни REST](REST.md#rest-representational-state-transfer)

### [REST] 01:07 Представим, что мы хотим написать простенький интернет-магазин. Есть сущность заказа — Order. Как будут выглядеть основные урлы: создание заказа, перемещение заказа в отдел отправки, удаление заказа, изменение? Тип запроса, урл и т.д., просто проговорить вслух.
* **Мой ответ:** REST в основе подразумевает использование HTTP протокола, в частности это значит, что должны использоваться методы этого протокола, чтобы они ложились на CRUD операции. То есть GET на получение, POST на создание, PUT на изменение, PATCH на частичное изменение.
* **Интервьюер (перебивает):** Меня даже конкретные урлы под эту задачу интересуют, не просто принципы. Нам нужно создать конкретно заказ, как будет выглядеть URL?
* **Мой ответ:** `/orders` метод POST.
* **Интервьюер:** Если нужно изменить какую-то позицию в заказе?
* **Мой ответ:** Добавляется параметр PathVariable...
* **Интервьюер:** Перефразирую: мы хотим изменить заказ полностью, было 5 позиций, мы хотим изменить их все.
* **Мой ответ:** Метод PUT, `/orders/{id}`.
* **Интервьюер:** А если какую-то одну позицию хотим?
* **Мой ответ:** PATCH.
* **Интервьюер:** Если бы в нем было три свойства, мы хотим изменить только одно, мы что будем в бади передавать используя PATCH? Все или один какой-то?
* **Мой ответ (сомневаясь):** То, что конкретно хочешь изменить, ты должен передавать. Если тебе не нужны оставшиеся поля, скорее всего, их нельзя передавать.
* **Интервьюер:** А если мы передали только одно, остальные на входе условно будут как null. Если есть какое-то значение — мы его обновляем, если пришел null — мы его не трогаем. А если мы одно из них хотим именно в null выставить, стереть? В чем отличие игнорирования от стирания при PATCH, как решать эту проблему?
* **Мой ответ:** Не знаю.
* **Анализ:** Не сразу понял вопрос. Вместо того чтобы сразу приступить к практическому проектированию URL, начал объяснять общую теорию REST.
* **Правила именования:** Забыл, что URL должен содержать префикс и версию: `POST /api/v1/orders`. Имя ресурса всегда во множественном числе, а данные передаются в теле (body).
* **Пробел в PATCH:** Не смог четко ответить, что передавать в PATCH — передаем только то поле, которое меняем. Остальные на сервисе обычно фильтруются проверкой `if (field != null)`.
* **Проблема null-значения:** Не смог объяснить, как в PATCH игнорировать фильтр на `null`, если нужно именно стереть (обнулить) значение в БД:
  * **Решение через PUT (совет ментора):** Заменить PATCH на PUT. Он ничего не проверяет и перезаписывает объект целиком — так мы гарантированно занулим поле.
  * **Решение через Map:** Передавать данные в `Map<String, Object>`. Наличие ключа в мапе (`containsKey`) служит признаком того, что поле нужно обновить, даже если пришел `null`.
**Материал:** [Практика проектирования REST](REST.md#практика-проектирования-rest-api)

### [Spring] 01:14 Есть API на создание заказа на работу с ордерем и сейчас получать get orders и post orders может кто угодно, просто контроллер и репозиторий внутри и больше ничего. И нам надо сделать так чтобы в одну api создавать мог пользователь с одной ролью, а смотреть пользователь с другой, создает только покупатель, а смотрит только менеджер. Что нам нужно сделать в проекте чтобы такая ролевая модель заработала?
* **Мой ответ:** Добавляется секьюрити фреймворк, он добавляет фильтры через которые запрос проходит, авторизация в том числе. Настраивается при помощи HttpSecurity, в нем можно прописать настройки, какие запросы мы хотим чтобы фильтровались, были возможны только для конкретного пользователя.
* **Интервьюер:** А что нам надо, вот мы подключили Security, что то еще создать какие-то файлы, как то настроить, ну вот есть конкретный метод контроллера, что внего может только бальзак с одной, ролью попасть, а во второй метод только пользователь с другой ролью. представим что у нас jwt токен, нам ни надо хранить ни роли, ни чего у нас в базе, максимально упрощенная модель будет. То-есть бальзак запрос пришел, сразу в токене указана какая роль, что нужно сделать на низком уровне?
* **Мой ответ:** Если авторизация через jwt токен, все роли в нем хранятся, он должен как-то извлечься из запроса, затем извлечься роли. Я с ролями и jwt токеном не работал.
* **Анализ:** Опять меня попросили конкретный пример, а я рассказал базу. Интервьюер ждал понимания механики «под капотом»: создание конфигурационного бина `SecurityFilterChain` и использование `@PreAuthorize` над методами.
* **Низкий уровень JWT:** Я не работал с JWT на практике и не до конца понимал, что в Stateless-режиме проверка идет через **валидацию подписи токена секретным ключом**. Сервер не идет в базу, он вычисляет хеш и, если подпись совпала, доверяет ролям из токена.
* **Материал:** [Spring Security](Spring.md#spring-security)

### [Spring] 01:17 Есть API findAll, которое возвращает заказы. Сначала их было 10, потом 100, потом 1000 — фронтенд их нормально отображал. Но когда записей стало 1 000 000, фронт начал тормозить. Что делать, как решать проблему?
* **Мой ответ**: Использовать пагинацию.
* **Интервьюер**: А какая-то встроенная поддержка пагинации в Spring есть?
* **Мой ответ**: Да.
* **Интервьюер**: Можешь описать, какая примерно? Может, какие-то классы вспомнишь, куда передавать, любые детали?
* **Мой ответ**: Аннотация какая-то... В наш метод эндпоинта прилетает «пагинатор», он внедряется Спрингом, и мы можем его просто в запрос подставить, и он уже сам скачивает нужные записи, используя Offset и Limit.
* **Анализ:** Я правильно назвал принцип, но плавал в названиях классов. В методе контроллера, интерфейс **`Pageable`** принимает параметры (номер страницы, размер, сортировка). Далее передается в метод Spring Data. Интерфейс **`Page`** возвращает не только список, но и метаданные (общее количество записей/страниц).
* **Материал:** [Пагинация в Spring Data](Spring.md#пагинация-в-spring-data)

### [Spring] 01:19 Нам нужно фильтровать данные по множеству полей (например, 50 фильтров), которые могут комбинироваться. Как это реализовать?
* **Мой ответ:** Есть специальный класс, он позволяет динамически задавать эти поля, можно условия задавать, как проверять. Как он называется — я забыл. Вообщем есть возможность динамически настраивать фильтр для запроса, чтобы null-значения игнорировались.
* **Анализ:**
Я правильно вспомнил концепцию, но забыл ключевые термины.
1. **Суть вопроса:** Интервьюер проверял умение избегать "комбинаторного взрыва" методов в репозитории. Если писать `findBy...` на каждое поле, поддержка кода станет невозможной. Даже 50 `if` в сервисе — это плохой тон (Boilerplate).
2. **Уточнение по DTO:** Важно понимать, как приходят данные. Если поля фиксированы в таблице и не планируют расширяться — подойдет **Specification** для добавления предикатов по условию. Если свойства динамические, то можно использовать `Map` (ключ-значение) + EAV и добавлять предикаты в цикле.
3. **NoSQL как альтернатива:** Для таких задач часто используют Elasticsearch или MongoDB, так как они созданы для гибких схем. Но если мы остаемся в рамках SQL, нам нужно архитектурное решение.
4. **EAV-модель:** Я использовал эту модель для хранения динамических характеристик товаров без изменения структуры таблиц.
* **Материал:** [Динамические фильтры и Specification](Spring.md#динамическая-фильтрация)

### [SQL] 1.20 Что можешь про EXPLAIN рассказать?
* **Мой ответ:** Можно посмотреть план выполнения запроса и какие индексы используются. Если запрос медленный — первым делом вызываем EXPLAIN. EXPLAIN строит план по статистике, а ANALYZE реально выполняет запрос.
* **Интервьюер:** А что в EXPLAIN будет привлекать внимание? Что глаз будет искать в первую очередь?
* **Мой ответ:** Cost (стоимость), время выполнения, используются ли индексы.
* **Интервьюер:** А как мы поймем, используются ли индексы? Если запрос большой, что искать через Ctrl+F, на что "возбудиться", что идет не так?
* **Мой ответ:** (Здесь нужно было назвать типы сканирования).
* **Анализ:** Ответ правильный по сути, но не хватило "ключевых слов", которые ищет глаз разработчика в плане.
* **Что искать (Ctrl+F):**
  * **Seq Scan** (Sequential Scan) — это ПЛОХО. Это значит, что БД читает всю таблицу целиком, пропуская индексы. Именно это мы ищем, чтобы "возбудиться".
  * **Index Scan** / **Index Only Scan** — это ХОРОШО. БД использует индекс.
  * **Cost и Actual Time:** Мы смотрим на узлы с самым большим `actual time` — это "узкие места".
* **Материал:** [SQL: Индексы и Explain](SQL.md#оптимизация-запросов-explain)