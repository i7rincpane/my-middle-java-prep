# Презентации рабочих кейсов
* ### [Самопрезентация](#self-presentation-p)
* ### [Модуль интеграции со СМЭВ-Госуслуги (Оценка качества услуг)](#assessment-quality-services-p)
* ### [Модуль интеграции с ФСС (родовые сертификаты - родильный дом)](docs/instrukciya_ers(rod_dom).pdf)
* ### [DNS-Shop: Маркетплейс с динамическими характеристиками (EAV)](#dns-shop-p)

## <a id="self-presentation-p">Самопрезентация</a>
Здравствуйте, меня зовут Павел. Я Java-разработчик с опытом более 6 лет.

Первые три года занимался доработкой функционала действующей медицинской информационной системы и разработкой модулей для межведомственного электронного документооборота.

С 2023 года наша организация перешла на централизованную платформу от вендора. Моя роль сместилась в сторону анализа данных и бизнес-логики — я занимаюсь сложной медицинской аналитикой, SQL-отчётностью и напрямую работаю с пользователями.

Моя ключевая ценность в том, что я напрямую общаюсь с врачами, быстро понимаю их потребности и могу перевести их в технические решения, используя low-code платформу и базы данных.

Один из последних реализованных кейсов — модуль отправки данных о медицинской помощи в ЕПГУ (Госуслуги). API Госуслуг построено на асинхронной модели с опросом статусов. Я реализовал три независимых воркера, предусмотрел механизмы для исключения дублирования и решил ключевую проблему с «плавающими» идентификаторами — перевёл идентификацию услуг с технических ID на натуральный бизнес-ключ: «Кто + Что + Когда».

Для конкурентной обработки записей использовал `FOR UPDATE SKIP LOCKED` — полностью на стороне PostgreSQL, без дополнительных сервисов.
Решение успешно тиражировано на 10+ медицинских организаций.

Сейчас я целенаправленно поддерживаю свои Java-компетенции через пет-проект — интернет-магазин на Spring Boot 3. В нём реализовал:

- EAV-модель для динамических характеристик товаров;
- сложную фильтрацию через реляционное деление (GROUP BY + HAVING) и Criteria API;
- собственный CPredicate Builder, сокративший boilerplate-код на 70%;
- пессимистические блокировки с защитой от дедлоков (сортировка ID);
- гибрид JPA и JDBC с потоковой обработкой через ResultSetExtractor;
- рекурсивные CTE для иерархических категорий;
- интеграционное тестирование с Testcontainers и покрытие JaCoCo 60%.
- защита функционала по ролям

Проект в открытом доступе, готов показать код.

Параллельно изучаю микросервисную архитектуру: Spring Cloud, Kafka, Docker.

Ищу удалённую работу Java-разработчиком. Готов к задачам любой сложности, быстро погружаюсь в новый контекст и ценю возможность влиять на качество продукта.

Спасибо за внимание!


## <a id="assessment-quality-services-p">Модуль интеграции со СМЭВ-Госуслуги (Оценка качества услуг)</a>


Одной из моих последних задач была разработка системы доставки данных о медицинских услугах в федеральную систему оценки качества (ЕПГУ/Госуслуги).
Нам требовалось решение, которое можно было бы быстро тиражировать в разные медорганизации без развертывания дополнительных внешних сервисов.
Поэтому я реализовал всю логику внутри **PostgreSQL**, используя расширение `plpython3u` для сетевых вызовов и планировщик `pg_cron` для автоматизации.

В команде проекта было 5 человек: разработчик шлюза СМЭВ (через который осуществлялся доступ к госуслугам), медицинский аналитик, постановщик задачи, инженер внедрения и я в роли ведущего разработчика интеграции. Архитектурно API Госуслуг построено на асинхронной модели (Polling pattern): сначала мы отправляем сообщение, а затем периодически опрашиваем систему для получения результата обработки.

### Система состоит из трех независимых воркеров (джоб), которые управляют жизненным циклом сообщения. 

1. Первый воркер (экстрактор-сборщик) выбирает услуги, для которых еще нет записи в логе (используя `NOT EXISTS`). Он пытается сохранить запись в лог, и только в случае успеха (отсутствие ошибки уникальности) выполняет сетевой вызов, предварительно закоммитив запись.
Это гарантирует, что на уровне изоляции `Read Committed` другие процессы мгновенно увидят, что услуга уже в обработке, и не выберут её повторно.

2. Второй воркер (поллер-опросник) работает только с таблицей логов. Он опрашивает API по записям в статусе SENT. Здесь я применил FOR UPDATE SKIP LOCKED, чтобы воркеры не блокировали друг друга и мы избежали проблемы Lost Update при обновлении статусов. 

3. Третий воркер (регенератор с retry) собирает все услуги с ошибками (ERROR), отказами (REJECTED) и зависшими старыми записями NEW (created_at < NOW() - INTERVAL '10 minutes'). Здесь также применяется FOR UPDATE SKIP LOCKED для предотвращения гонки данных (Race Condition) и исключения дублирования отправки параллельными cron-процессами.
Чтобы избежать бесконечных отправок записей с ошибками, я реализовал инкрементальный счётчик попыток (Retries). Если лимит исчерпан, запись помечается для ручного разбора.

### Дополнительно

* Для предотвращения каскадных сбоев запросы отправляются с ограничениями по времени.
* Для безопасности используется токен, который хранится в таблице настроек. Функция обращается к таблице с правами создателя: (SECURITY DEFINER), что подразумевает ограниченный доступ.
* Полный жизненный цикл каждой отправки (Request/Response) сохраняется в БД.

### Проблемы с которыми пришлось столкнуться
В процессе эксплуатации я столкнулся с проблемой legacy-источника: **«плывущими» идентификаторами**. Врачи могли удалять и пересоздавать записи об услугах задним числом, из-за чего технический `patserv_id` менялся.
Система видела пересозданную услугу как новую и могла отправить её повторно, что приводило к дублированию анкет у пациента.
Я понял, что на технические ID полагаться нельзя, и перепроектировал систему на составные натуральные ключи.
Я выделил связку «Кто, Что и Когда» (ID пациента + код услуги + дата).
С точки зрения бизнеса — это и есть уникальный факт оказания услуги.
Если эти данные те же — значит, это та же услуга, даже если в базе у неё новый ID

### Итог: Решение было оформлено в виде параметризованного пакета и успешно тиражировано на 10+ медицинских организаций.

##  <a id="dns-shop-p">[Пет-проект]  DNS-Shop: Маркетплейс с динамическими характеристиками (EAV)</a>

**Ссылка на проект:** <https://github.com/i7rincpane/2024-01-dmdev-ppavel/tree/spring>

### Постановка задачи и бизнес-требования
Разработка интернет-магазина с гибкой системой характеристик. Основная проблема: у разных категорий товаров (чайники, холодильники, сковороды) абсолютно разный набор свойств. Требовалось реализовать иерархический каталог и фильтрацию по любому количеству динамических параметров.

### Стек технологий
* Backend: Java 18, Spring Boot 3.2.3 (MVC, Data JPA, Security).
* Database: PostgreSQL 14, Liquibase (миграции), Hibernate 6.
* Performance: Ehcache 3 (L2 Cache).
* Quality: Testcontainers, JUnit 5, JaCoCo (60% coverage).

### Ключевые технические решения

#### Гибкая модель данных (EAV)
Вместо создания сотен таблиц под каждую категорию, я выбрал модель **EAV (Entity-Attribute-Value)**. Это позволило добавлять новые категории и характеристики (мощность, диаметр, объем) через интерфейс без DDL-операций.

#### Сложная фильтрация (Set Theory + Criteria API)
Поскольку в EAV свойства — это отдельные строки, я применил **реляционное деление** (`GROUP BY + HAVING COUNT(*) = N`). Это гарантирует, что товар обладает всеми выбранными фильтрами. Для динамического построения запросов (обработка `null`, диапазоны цен) я разработал декларативный **CPredicate Builder** над JPA Criteria API. Это сократило boilerplate-код.

```java
//Преобразование maps свойств в лист предикатов
Predicate[] predicates = CPredicate.builder()
.add(filter.getPriceFrom(), filter.getPriceTo(), cb::between)
.add(filter.getProducerIds(), root.get("producer")::in)
.add(productFilter.getPropertyIdFloatValueFrom(),
                        productFilter.getPropertyIdFloatValueBy(),
                        (value1, value2, key) ->
                                cb.and(CPredicate.builder()
                                        .add(value1, value2, (param1, param2) -> cb.between(productProperties.get(ProductProperty_.FLOAT_VALUE), param1, param2))
                                        .add(value2, param -> cb.lessThan(productProperties.get(ProductProperty_.FLOAT_VALUE), param), Objects.isNull(value1))
                                        .add(value1, param -> cb.greaterThan(productProperties.get(ProductProperty_.FLOAT_VALUE), param), Objects.isNull(value2))
                                        .add(key, param -> cb.equal(property.get(Property_.ID), param))
                                        .build())
                )
.build();
```

#### Конкурентность и предотвращение Deadlocks
При оформлении заказа используется **пессимистическая блокировка** (`PESSIMISTIC_WRITE`) на записях товаров.
*   **Бизнес-логика:** Гарантия положительного баланса (First commit wins).
*   **Отказоустойчивость:** Для предотвращения "зависания" потоков настроен `QueryHint` с таймаутом.
*   **Anti-Deadlock:** Реализована **принудительная сортировка ID** товаров перед блокировкой. Все процессы захватывают строки в едином порядке (по возрастанию ID), что физически исключает циклическое ожидание и дедлоки.

#### Иерархия категорий и рекурсивные CTE
Категории организованы в дерево произвольной вложенности.
*   Для построения навигационной цепочки (Breadcrumbs) от текущей категории до корня используется **Recursive CTE** (SQL запрос с рекурсией).
*   **Оптимизация:** Результаты запросов к дереву кэшируются через **L2 Cache Hibernate**, что минимизирует нагрузку на БД при навигации пользователей.

#### Гибридный доступ к данным: JPA + JDBC
Для тяжелой аналитики (подсчет количества товаров для каждого фильтра) я использовал JDBC + ResultSetExtractor. Это позволило обрабатывать миллионы строк потоково без выгрузки всего ResultSet в память, что предотвратило ошибки OutOfMemory.

#### Безопасность и управление сессией (Spring Security)
Реализована авторизация через БД с разграничением ролей (**USER / ADMIN**).
*   **ADMIN:** Корректировка характеристик и управление каталогом.
*   **USER:** Просмотр и оформление заказов.
*   **Корзина:** В Security-цепочку добавлен кастомный обработчик (`AuthenticationSuccessHandler`), который при логине сопоставляет корзину из сессии с корзиной в БД, проверяя принадлежность данных текущему пользователю.

#### Тестирование и миграции
*   **Testcontainers:** Интеграционные тесты запускаются в реальной среде PostgreSQL (Docker).
*   **Liquibase:** Все изменения схемы БД и справочных данных строго версионированы.