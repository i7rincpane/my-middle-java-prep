# Hibernate
* ### [работа Hibernate с ключами и контекстом](#Работа-Hibernate-с-ключами-и-контекстом)

## Работа Hibernate с ключами и контекстом

### 1. Зачем Hibernate первичный ключ?
Первичный ключ (любого типа) — это фундамент работы **First Level Cache** (Persistence Context).

* **Идентификация (Identity Map):** Hibernate гарантирует, что в рамках одной сессии (транзакции) для одной строки из БД всегда существует только один экземпляр Java-объекта. Это предотвращает ситуацию, когда два разных объекта в памяти представляют одну и ту же запись в базе.
* **Dirty Checking (Механизм грязной проверки):**
    1. При загрузке сущности Hibernate сохраняет её копию (snapshot) в кеше.
    2. При коммите транзакции он достает объект по ID и сравнивает его со снимком.
    3. Если поля изменились — выполняется `UPDATE`.
       *Это позволяет не вызывать `save()` вручную для обновления данных.*
* **Lazy Loading:** Когда мы загружаем связанную сущность лениво, Hibernate создает "прокси-объект", в котором заполнено только поле ID. Реальные данные подтянутся только при обращении к полям.

### 2. Суррогатный vs Составной ключ в реализации Hibernate

* **Суррогатный ID:** Рекомендуемый стандарт. Использует стратегии генерации (`IDENTITY`, `SEQUENCE`), что снимает с разработчика ответственность за уникальность перед вставкой.
* **Составной ключ:**
    * Требует создания вспомогательного класса с аннотацией `@Embeddable` (или `@IdClass`).
    * **Обязательно:** Реализация `equals()` и `hashCode()`. Если их не будет, Hibernate не сможет найти объект в Persistence Context по ключу, что приведет к дублированию объектов или ошибкам.
    * **Ручное управление:** Составной ключ должен быть полностью сформирован перед вызовом `persist()`, так как БД не умеет инкрементировать несколько полей как единый ключ.