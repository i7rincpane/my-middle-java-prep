# Топ 20 вопросов на мой стек

## ООП (Объектно-ориентированное программирование)
1. В чем разница между композицией и агрегацией?
2. Почему Java не поддерживает множественное наследование классов?
3. Расскажи про принципы **SOLID** на практических примерах.
4. В чем разница между абстрактным классом и интерфейсом (Java 8+)?
5. Что такое **Liskov Substitution Principle** и как его не нарушить?
6. Зачем нужен принцип инверсии зависимостей (**DIP**)?
7. Чем ковариантность отличается от контравариантности в контексте ООП?
8. Как работает динамический полиморфизм в рантайме?
9. Что такое «хрупкий базовый класс» (**Fragile Base Class**)?
10. Преимущества инкапсуляции при масштабировании проекта.
11. В чем разница между **Strong, Soft, Weak** и **Phantom** ссылками?
12. Как реализовать неизменяемый (**Immutable**) класс?
13. Почему стоит предпочитать композицию наследованию?
14. Что такое паттерн «Делегирование»?
15. Какие проблемы решает паттерн «Одиночка» (**Singleton**) и какие у него минусы?
16. Что такое **DRY, KISS** и **YAGNI**?
17. Как работает механизм динамической диспетчеризации методов?
18. Чем отличается зацепление (**Coupling**) от связности (**Cohesion**)?
19. В чем смысл принципа открытости/закрытости (**OCP**)?
20. Как ООП помогает в тестировании (Unit tests)?

## Java Core
1. Как работает **JVM Memory Model** (Heap vs Stack)?
2. Разница между `==` и `.equals()`. Как переопределить `hashCode` правильно?
3. Как работает **Garbage Collector**? Назови основные виды (G1, ZGC).
4. Что нового появилось в **Java 17/21** (Records, Sealed classes, Virtual Threads)?
5. Иерархия исключений. В чем разница между **Checked** и **Unchecked**?
6. Как работает **HashMap** внутри? Что такое коллизия?
7. Разница между **fail-fast** и **fail-safe** итераторами.
8. Что такое **Generics** и как работает **Type Erasure**?
9. Как работают **Wildcards** (`<? extends T>` vs `<? super T>`)?
10. Жизненный цикл потока в Java.
11. Разница между `Runnable` и `Callable`.
12. Что такое **Java Memory Model (JMM)** и зачем нужно `volatile`?
13. Как работают `synchronized` блоки и методы?
14. Что такое **Deadlock, Livelock** и **Starvation**?
15. Для чего нужен `CompletableFuture`?
16. Как работает **Stream API** (промежуточные и терминальные операции)?
17. Что такое **Functional Interfaces**? Назови основные (Predicate, Consumer и т.д.).
18. Как работает механизм **Reflection API** и где он применяется?
19. Что такое **ClassLoader** и иерархия загрузки классов?
20. Разница между **Inner** и **Static Nested** классами.

## Spring Boot
1. Что такое **Inversion of Control (IoC)** и **Dependency Injection (DI)**?
2. Жизненный цикл бина в Spring.
3. Разница между `@Component`, `@Service`, `@Repository`, `@Controller`.
4. Как работает `@Transactional`? Что такое **Propagation** и **Isolation**?
5. Что такое **Spring Boot Starters** и как работает автоконфигурация?
6. Как переопределить бин в Spring Boot?
7. Способы внедрения зависимостей (через конструктор, сеттер, поле). Что лучше?
8. Как работает **Spring AOP** (Proxy, Aspect, JoinPoint)?
9. Что такое **Spring Bean Scopes** (Singleton, Prototype, Session, Request)?
10. Для чего нужен **Spring Boot Actuator**?
11. Как настроить профили (`@Profile`) в приложении?
12. Разница между `BeanFactory` и `ApplicationContext`.
13. Как обрабатывать исключения глобально (`@ControllerAdvice`)?
14. Как работает фильтрация и безопасность в **Spring Security**?
15. Что такое **BeanPostProcessor** и **BeanFactoryPostProcessor**?
16. Как запустить задачу по расписанию (`@Scheduled`)?
17. Как работает интеграционное тестирование с `@SpringBootTest`?
18. Как использовать **Spring Initializr** для старта проекта?
19. Чем отличается `@RestController` от `@Controller`?
20. Как управлять внешними конфигурациями (`application.yaml`, переменные окружения)?

## Hibernate ORM & JPA
1. Разница между **JPA** и **Hibernate**.
2. Состояния сущности в Hibernate (**Transient, Persistent, Detached, Removed**).
3. Проблема **N+1** и способы ее решения (`EntityGraph`, `Join Fetch`).
4. Как работает **L1** и **L2** кеширование?
5. Разница между `get()` и `load()`.
6. Как работает ленивая загрузка (**Lazy Loading**)? Что такое `LazyInitializationException`?
7. Как маппить связи `@OneToMany`, `@ManyToOne`, `@ManyToMany`?
8. Что такое **MappedSuperclass**?
9. Разница между стратегиями наследования (`SINGLE_TABLE`, `JOINED`, `TABLE_PER_CLASS`).
10. Что такое **Dirty Checking**?
11. Для чего нужен `EntityManager` и `SessionFactory`?
12. Разница между оптимистической и пессимистической блокировками.
13. Как работают каскадные операции (`CascadeType`)?
14. Что такое **Orphan Removal**?
15. Как использовать **Criteria API** и когда это нужно?
16. Зачем нужен `persistence.xml` или аннотации конфигурации?
17. Как Hibernate работает с транзакциями БД?
18. Использование `@Query` в Spring Data JPA (Native vs JPQL).
19. Как работают конвертеры (`@Convert`)?
20. Как маппить перечисления (`@Enumerated`)?

## SQL & PostgreSQL
1. Разница между **INNER, LEFT, RIGHT, FULL JOIN**.
2. Что такое индексы (**B-tree, Hash**) и как они ускоряют поиск?
3. Уровни изолированности транзакций (**ACID**).
4. Разница между `WHERE` и `HAVING`.
5. Что такое нормализация (1NF, 2NF, 3NF)?
6. Как работает **EXPLAIN ANALYZE** в PostgreSQL?
7. Разница между `DELETE`, `TRUNCATE` и `DROP`.
8. Что такое оконные функции (**Window Functions**)?
9. Как работают хранимые процедуры и функции?
10. Что такое представления (**Views**) и материализованные представления?
11. Разница между первичным (`Primary Key`) и уникальным (`Unique Key`) ключами.
12. Как работают внешние ключи (`Foreign Key`) и `ON DELETE CASCADE`?
13. Что такое транзакционные логи (**WAL**) в Postgres?
14. Как бороться с «мертвыми» строками (**VACUUM**)?
15. Типы данных в Postgres (**JSONB** vs **JSON**).
16. Как работает полнотекстовый поиск в PostgreSQL?
17. Что такое обобщенные табличные выражения (**CTE**)?
18. Как реализовать шардирование и партиционирование таблиц?
19. Разница между репликацией **Master-Slave** и **Master-Master**.
20. Как работает пул соединений (**HikariCP**)?

## API, REST & SOAP
1. Главные принципы архитектуры **REST**.
2. Разница между **REST** и **SOAP**.
3. Назови основные HTTP методы и их идемпотентность.
4. Структура SOAP-сообщения (Envelope, Header, Body).
5. Что такое **WSDL** и зачем он нужен?
6. Коды ответов HTTP (2xx, 3xx, 4xx, 5xx).
7. Что такое **HATEOAS**?
8. Как работает аутентификация через **JWT**?
9. Разница между авторизацией и аутентификацией.
10. Что такое **CORS** и как его настроить?
11. Как версионировать API?
12. Что такое **Swagger/OpenAPI** и зачем он разработчику?
13. Как передавать большие файлы через REST API?
14. Что такое **Idempotency Key** и зачем он нужен?
15. Как работает протокол **HTTP/2** по сравнению с 1.1?
16. Преимущества использования JSON перед XML в REST.
17. Что такое **GraphQL** и в чем его отличие от REST?
18. Как реализовать пагинацию и фильтрацию в API?
19. Что такое **Rate Limiting**?
20. Как тестировать API (Postman, RestAssured)?

## Apache Kafka
1. Основные компоненты Kafka (Producer, Consumer, Broker, Topic, Partition).
2. Что такое **Consumer Group** и как происходит ребалансировка?
3. Гарантии доставки сообщений (**At-most-once, At-least-once, Exactly-once**).
4. Зачем нужен **Zookeeper** (или KRaft) в кластере Kafka?
5. Что такое **Offset** и как им управлять?
6. Как обеспечивается высокая доступность и отказоустойчивость?
7. Что такое **Retention Policy**?
8. Как работает **Log Compaction**?
9. Разница между топиком и очередью.
10. Как работает сериализация и десериализация (Avro, JSON)?
11. Что такое **Backpressure** и как с ним бороться?
12. Роль **Partition Key** в распределении данных.
13. Как работает **Kafka Streams**?
14. Что такое **Schema Registry**?
15. Как мониторить состояние Kafka-кластера?
16. Разница между Kafka и RabbitMQ.
17. Что такое **ISR** (In-Sync Replicas)?
18. Как Producer подтверждает отправку (**acks=0, 1, all**)?
19. Как реализовать повторные попытки (**Retries**) и **Dead Letter Topics**?
20. Как Kafka хранит данные на диске?

## Git, Maven & JUnit
1. **Git:** Разница между `git fetch` и `git pull`.
2. **Git:** Что такое `git rebase` и чем он отличается от `git merge`?
3. **Git:** Как отменить последний коммит (`reset` vs `revert`)?
4. **Git:** Что такое **Gitflow**?
5. **Git:** Зачем нужен `git stash`?
6. **Maven:** Жизненный цикл сборки (**Lifecycle, Phases, Goals**).
7. **Maven:** Разница между `dependencyManagement` и `dependencies`.
8. **Maven:** Что такое **Scope** в зависимостях (`compile, runtime, test, provided`)?
9. **Maven:** Как Maven разрешает конфликты версий библиотек?
10. **Maven:** Для чего нужны профили в `pom.xml`?
11. **JUnit:** Аннотации `@Test, @BeforeEach, @AfterEach, @BeforeAll, @AfterAll`.
12. **JUnit:** Как протестировать исключение в JUnit 5?
13. **JUnit:** Разница между модульными (**Unit**) и интеграционными тестами.
14. **JUnit:** Что такое **Mockito** и как работают `@Mock`, `@Spy`, `@InjectMocks`?
15. **JUnit:** Как использовать параметризованные тесты?

## JavaFX
1. Как работает архитектура FXML и контроллеров?
2. Что такое `Stage` и `Scene`?
3. Жизненный цикл приложения JavaFX.
4. Как обновлять UI из другого потока (`Platform.runLater`)?
5. Разница между `Property` и обычными полями (Data Binding).
6. Что такое `ObservableList` и зачем он нужен?
7. Как работает механизм CSS в JavaFX?
8. Зачем нужен класс `Task` и `Service` для фоновых задач?
9. Разница между `Group` и `Pane`.
10. Как реализовать навигацию между экранами?
11. Как обрабатывать события (Event Handling)?
12. Что такое `Canvas` API?
13. Как работают Layout Managers (`HBox, VBox, GridPane, BorderPane`)?
14. Как передать данные между контроллерами?
15. Что такое `CellFactory` в ListView/TableView?
16. Как сделать приложение адаптивным (Responsive)?
17. Роль файла `module-info.java` в JavaFX приложениях.
18. Как использовать графики (**Charts API**)?
19. Как реализовать Drag-and-Drop?
20. Как упаковать приложение для распространения (jlink, jpackage)?
