# Базы данных & SQL
* ### [Оптимизация запросов: EXPLAIN](#explain-p)
* ### [Классификация первичных ключей (Primary Keys)](#primary-keys-p)
* ### [Управление типом связи через ограничения (Constraints)](#constraints-p)
* ### [Выбор стратегии хранения связи: Column vs Join Table](#column-join-table-p)
* ### [Шардирование (Sharding)](#sharding-p)
* ### [Работа с последовательностями (Sequences)](#sequences-p)
* ### [Сравнение суррогатных ключей: BIGINT против UUID](#surrogate-key-p)
* ### [Блокировки в SQL: FOR UPDATE и FOR SHARE](#locking-p)
* ### [Транзакции и ACID](#transactions-acid)

## <a id="explain-p">Оптимизация запросов: EXPLAIN</a> 

Оптимизация начинается не с переписывания кода, а с чтения плана запроса. БД сама говорит, где ей "больно".

### Разница между EXPLAIN и ANALYZE
*   **EXPLAIN:** БД строит план выполнения на основе накопленной статистики (сколько строк в таблице, насколько данные уникальны). Запрос **не выполняется**.
*   **ANALYZE:** БД реально **выполняет** запрос и замеряет время.
*   *Зачем оба:* Чтобы сравнить `Expected Rows` (сколько БД ожидала найти) и `Actual Rows` (сколько нашла на самом деле). Если разница в 10-100 раз — статистика БД "протухла", индексы могут работать неэффективно (analyze обновляет стат. информацию).

### Виды чтений (Сканирования) 

| Тип сканирования | Описание | Когда "возбудиться" (Ctrl+F) |
| :--- | :--- | :--- |
| **Seq Scan** | Чтение всей таблицы подряд. | Если таблица большая (>10к строк), а мы ждем скорости. |
| **Index Scan** | БД идет в индекс, находит адрес строки, а потом идет за данными в таблицу (Heap). | Если данных много, а Index Scan все равно медленный (много случайного чтения). |
| **Index Only Scan** | **Идеал.** Все данные уже есть в индексе. БД вообще не лезет в таблицу. | Добиваемся этого через `COVERING INDEX` (INCLUDE). |
| **Bitmap Index Scan** | "Умный" индекс. Сначала находит все нужные страницы в памяти, строит карту и читает их пачкой. | Часто встречается при сложных условиях `AND/OR`. |

### Covering Index (Покрывающий индекс)
Позволяет добиться **Index Only Scan**.
`CREATE INDEX idx_user_email ON users(name) INCLUDE (email);`
*   **Суть:** Мы добавляем `email` в "тело" индекса по имени. При запросе `SELECT email WHERE name = ...` база вообще не обращается к файлу таблицы, забирая всё из индекса.

### Виды соединений (Joins)

### Nested Loop Join (Вложенный цикл)
*   **Алгоритм:** Для каждой строки из внешней таблицы база сканирует внутреннюю таблицу.
*   **Пример:** 10 заказов и 1 млн пользователей. Если по `user_id` есть индекс, база просто 10 раз быстро прыгнет в индекс.
*   **Минус:** Если индекса нет, база сделает 10 млн проверок.

Ищем заказы пользователя по его ID:

`EXPLAIN ANALYZE SELECT * FROM orders o JOIN users u ON o.user_id = u.id WHERE o.id = 100;`

План выполнения:

```text
Nested Loop  (cost=0.58..16.62 rows=1 actual time=0.034..0.036 loops=1)
  ->  Index Scan using orders_pkey on orders o  (cost=0.29..8.30 rows=1 actual time=0.013..0.014 loops=1)
        Index Cond: (id = 100)
  ->  Index Scan using users_pkey on users u  (cost=0.29..8.30 rows=1 actual time=0.015..0.015 loops=1)
        Index Cond: (id = o.user_id)
Planning Time: 0.154 ms
Execution Time: 0.082 ms
```

* **Внешняя петля**: База идет в таблицу orders по индексу (Primary Key) и находит ОДИН заказ с ID=100.
* **Внутренняя петля**: Берет user_id из этого заказа (например, 5) и идет в таблицу users. Там она мгновенно находит пользователя с ID=5 через его индекс (Primary Key).
* **Итог**: Сделано всего два быстрых прыжка по индексам.

### Hash Join (Хэш-таблица)
*   **Алгоритм:**
1. БД выбирает меньшую таблицу и строит по ней **Hash Map** в оперативной памяти.
2. Затем сканирует большую таблицу и мгновенно (за $O(1)$) ищет совпадения в этой мапе.
*   **Плюс:** Очень быстро для больших объемов.
*   **Минус:** Если мапа не влезет в `work_mem` (RAM), база начнет сбрасывать данные на диск, и всё "умрет".

### Sort Merge Join (Сортировка и слияние)
*   **Алгоритм:**
1. Сортирует обе таблицы по ключу связи.
2. Ставит два "курсора" в начало. Если значения совпали — сдвигает оба. Если в одной таблице значение меньше — двигает курсор только в ней.
*   **Плюс:** Не требует столько памяти, сколько Hash Join, и идеален, если данные уже отсортированы индексами.

### Пример реального плана запроса (PostgreSQL)

Допустим, мы ищем заказ по `user_id`:
`EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 500;`

```text
Index Scan using orders_user_id_idx on orders  (cost=0.29..8.31 rows=1 actual time=0.045..0.046 loops=1)
  Index Cond: (user_id = 500)
Planning Time: 0.088 ms
Execution Time: 0.071 ms
```
Как читать это "мясо":
* **cost=0.29..8.31**: 0.29 — цена получения первой строки, 8.31 — цена получения всех строк. (Те самые попугаи).
* **rows=1**: БД ожидает найти 1 строку (статистика).
* **actual time=0.045..0.046**: Реальное время в мс.
* **Index Cond**: Условие, по которому сработал индекс.

### Индексы и Селективность
* **Селективность**: это отношение количества уникальных значений к общему числу строк.
* **Высокая селективность (ближе к 1)**: ID, Email. Индекс работает идеально.
* **Низкая селективность (ближе к 0)**: Пол, Статус заказа (New/Paid).
* **Проблема**: Индекс по статусу Paid (которых 99%) бесполезен.

**Пошаговый процесс (Как это видит БД):**
1. **Индекс** — это отдельный файл. В нем лежат записи: `Paid -> адрес_строки_в_таблице`. Они отсортированы.
2. БД находит блок «Paid». В индексе они лежат подряд.
3. **Проблема:** Сами данные об оплате лежат в **основном файле таблицы (Heap)**. Там они разбросаны в случайном порядке (как их записывали).
4. Чтобы отдать `SELECT *`, БД должна для **каждого** «Paid» из индекса сходить в основной файл.
5. Если «Paid» — это 99% таблицы (например, 900к строк из 1000к), базе придется сделать **900 000 «прыжков»** (Random I/O) по диску.
6. **Вердикт:** Процессору быстрее прочитать всю таблицу подряд (`Seq Scan`), чем 900к раз прыгать в разные места. БД просто игнорирует индекс.

* **Решение**: Partial Index (Частичный индекс).
Мы создаем его, когда точно знаем, что искомых значений **очень мало** (высокая селективность условия).
*   **Пример:** `CREATE INDEX idx_orders_new ON orders(status) WHERE status = 'UNPAID';`  - 1% записей, которые нам реально нужно быстро находить

Если неоплаченных заказов всего 1%, индекс будет крошечным. Базе выгодно сделать 100-200 прыжков в таблицу, чем сканировать миллион строк.

## <a id="primary-keys-p">Классификация первичных ключей (Primary Keys)</a>

При проектировании таблиц важно различать происхождение и структуру ключей. Это влияет на производительность и стабильность связей.

Если мы создаем таблицу для связи пользователей и машин:
1. **id** — это суррогатный ключ (просто счетчик), цель которого — уникальность.
2. **user_id** и **car_id** — это натуральные ключи, состоящие из реальных бизнес-данных (ссылки на реальных людей и авто).
3. **(user_id, car_id)** — если мы сделаем их первичным ключом вместе, это будет **составной натуральный ключ**.

### Типы ключей по происхождению

| Характеристика | Суррогатный (Surrogate) | Натуральный (Natural) |
| :--- | :--- | :--- |
| **Происхождение** | Создается искусственно для нужд БД (ID, UUID). | Берется из предметной области (Email, VIN, ISBN). |
| **Бизнес-смысл** | Отсутствует. | Является значимой информацией. |
| **Создание** | **Автоматическое** (Identity, Sequence). | **Ручная подстановка** (из входящих данных). |
| **Стабильность** | Высокая. Не меняется при смене данных юзера. | Низкая. При смене Email придется обновлять все связи. |


### Сравнение Суррогатного и Составного подходов

**Суррогатный ID:**
* Нужно полностью изолировать связи от изменений бизнес-логики (данные меняются, но их нужно находить по стабильному ключу).
* На эту запись планируется ссылаться из других таблиц (чтобы не тащить составные FK).
* Стандарт для работы с [Hibernate](Hibernate.md#Работа-Hibernate-с-ключами-и-контекстом) (проще мапинг, не нужно создавать дополнительных классов).

**Составной ключ:**
* Технические ID нестабильны, пересоздаются или различаются в разных базах — связка натуральных полей, это единственный способ надежно идентифицировать запись.
* В простых "тупиковых" таблицах связей, на которые никто не ссылается. Экономия места на диске и в RAM (нет лишней колонки `id` и лишнего индекса по ней).

#### Пример: Уникальность на уровне структуры
Без составного ключа или UNIQUE-индекса в таблицу можно вставить дубликаты, которые сломают логику "одна машина — один юзер":
* `INSERT INTO user_car (id, user_id, car_id) VALUES (1, 10, 5);`
* `INSERT INTO user_car (id, user_id, car_id) VALUES (2, 10, 5);` — **Дубликат**, хотя технические ID разные.
  Составной PK сделает вставку второй строки невозможной.

#### Пример: Возможность ссылаться (Проблема Foreign Key)
Представим таблицу **Insurance** (Страховка) для связки "Юзер-Машина".
* **С суррогатным ID:** Нужна всего одна колонка-ссылка: `SELECT * FROM insurance WHERE user_car_id = 1;`.
* **С составным ключом:** Придется хранить и передавать оба поля: `SELECT * FROM insurance WHERE user_id = 10 AND car_id = 5;`. Это усложняет SQL и раздувает индексы.

#### Пример из рабочей практики: Когда суррогатный ID подвел
**Ситуация:** В приложении идентификаторы объектов постоянно удалялись и пересоздавались логикой. При миграции между базами (Dev/Prod) суррогатные ID одной и той же сущности различались.
**Проблема:** Приложение не могло идентифицировать уже существующую связь по `id`, считало её новой и плодило дубликаты одной и той же записи по бизнес-логике.
**Решение:** Использование **составного ключа** на основе бизнес-параметров. База сама гарантирует: если такая связка данных уже была — вторая не вставится. Это позволило использовать логику **Upsert**, опираясь на реальные данные, а не на случайные числа ID.

## <a id="constraints-p">Управление типом связи через ограничения (Constraints)</a>

Промежуточная таблица (Join Table) не всегда означает связь "Многие-ко-многим". Тип связи зависит от того, на какие колонки наложены ограничения уникальности.

### Как превратить Many-to-Many в One-to-Many
Представим таблицу `user_car (user_id, car_id)`.

* **Связь Many-to-Many:**
  `PRIMARY KEY (user_id, car_id)` или `UNIQUE (user_id, car_id)`.
  *Позволяет:* Юзеру 1 иметь Машину 10, а Юзеру 2 — ту же Машину 10.

* **Связь One-to-Many (Одна машина — один владелец):**
  `UNIQUE (car_id)`.
  *Гарантирует:* Машина 10 может появиться в таблице только **один раз**. Следовательно, у неё может быть только один владелец.

### Типичные ошибки при проектировании
Частая ошибка — наложение уникальности на **пару** полей (`user_id`, `car_id`), когда по бизнесу требуется ограничить только **одно** из них.

**Пример ошибки:**
Если мы хотим, чтобы у машины был один хозяин, но пишем `UNIQUE (user_id, car_id)`, база пропустит:
1. `user_id: 1, car_id: 10`
2. `user_id: 2, car_id: 10` -- **Ошибка бизнес-логики**, но база считает это уникальной связкой.

**Правильное решение:**
Наложение `UNIQUE` (или `PRIMARY KEY`) строго на ту колонку, которая должна быть уникальной в рамках связи. В нашем случае это `car_id`. В конце концов, мы просто дублируем id в таблице car, и хотя бы только по этому должны сделать его PK или как минимум уникальным.

### Избыточность ограничений (PK vs UNIQUE)
При проектировании важно избегать дублирования индексов.
*   **Первичный ключ (Primary Key)** автоматически создает уникальный индекс на указанные колонки и запрещает в них `NULL`.
*   Если вы уже объявили `PRIMARY KEY (user_id, car_id)`, создавать отдельно `UNIQUE (user_id, car_id)` **не нужно**. Это создаст два идентичных индекса, что замедлит операции вставки (`INSERT`) и обновления (`UPDATE`), так как базе придется обновлять обе структуры.

### Самый лаконичный способ One-to-Many
Если по условию задачи машина всегда принадлежит только одному человеку, самым эффективным решением будет сделать **`car_id` первичным ключом** таблицы связей:

`ALTER TABLE user_car ADD PRIMARY KEY (car_id);`

Это решение:
1.  **Бизнес-логика:** Гарантирует, что машина не привяжется к двум юзерам (уникальность).
2.  **Целостность:** Запрещает пустые значения (NOT NULL).
3.  **Производительность:** Создает минимально необходимый индекс для поиска владельца по машине.

## <a id="column-join-table-p">Выбор стратегии хранения связи: Column vs Join Table</a>

При проектировании связи One-to-Many (Один ко многим) выбор между Foreign Key в колонке и отдельной Join Table — это компромисс между простотой и масштабируемостью.

### Foreign Key в колонке (Классический подход)

Обычно речь идет о связи «один ко многим» (\(1:N\)), где ID родителя записывается прямо в строку дочерней таблицы.

*   **Плюсы:** Максимальная простота. Меньше джоинов в запросах (высокая скорость чтения).
*   **Минусы:**
*   **Жесткая структура (Отсутствие гибкости)**: Если бизнес-требования изменятся и связь превратится в «многие ко многим» (\(M:N\)), придется переписывать схему данных, мигрировать данные и менять логику приложения.
*   **Разреженность (NULLs):** Если связь есть не у всех записей, таблица и индексы растут впустую. Если у 1 млн пользователей машина есть только у 100, то колонка `car_id` будет на 99.9% пустой. Это неэффективно: таблица "пухнет", индексы по этой колонке становятся тяжелыми и медленными.
*   **Блокировки:**
    * На живой базе ALTER TABLE для добавления колонки может заблокировать таблицу на чтение/запись.
    * Для проверки целостности, при каждой вставке или обновлении строки с FK, базе нужно наложить краткосрочную блокировку (shared lock) на родительскую запись, чтобы проверить её существование. Это требует дополнительных ресурсов и может стать узким местом при нагрузке.
    * Если все связи лежат в основной таблице, то любое изменение любой связи блокирует всю строку этой таблицы(exclusive Lock).
*   **Нагрузка на запись:** Каждый индекс ускоряет поиск, но замедляет запись. При вставке базе нужно обновить не только саму строку, но и 10 индексов.

### Промежуточная таблица (Join Table)

Промежуточная таблица обычно используется для связей \(M:N\), но иногда её применяют и для \(1:1\) или \(1:N\), чтобы получить следующие плюсы:

*   **Поддержка связей «Многие ко многим»**: Можно в любой момент переделать связь (юзер - много машин, в машина - много юзеров) можно связать одну запись с неограниченным количеством других, не меняя структуру основных таблиц.
*   **Чистота основных сущностей**: Хранятся только существующие связи, нет никаких NULL. Нет колонок, которые относятся только к связям. Это упрощает чтение структуры и поддержку.
*   **Дополнительные метаданные связи**: В промежуточную таблицу очень удобно добавлять данные о самой связи:created_at (когда создана связь), role (какую роль играет пользователь в этом проекте), priority (порядок сортировки), is_active (флаг мягкого удаления связи).
*   **Гибкость**: Позволяет легко добавить атрибуты связи (дата покупки, цена) или сменить тип связи на Many-to-Many.
*   **Шардирование**: Таблицу связей можно вынести на отдельный инстанс (шард) независимо от основных таблиц.
*   **Удобство для полиморфных связей**: Если одна сущность может быть связана с разными типами объектов, проще иметь несколько промежуточных таблиц (например, post_tags, video_tags), чем пихать все возможные ID в одну таблицу tags.
*   **Изоляция данных**: Если нужно удалить связь, просто удаляете строку из таблицы связей. Это не затрагивает основные таблицы и снижает риск случайного удаления данных по каскаду (если ON DELETE CASCADE настроен неосторожно).
*   **Безопасные миграции:** Использование Join Table позволяет вносить изменения в структуру связей, не рискуя стабильностью основных тяжелых таблиц (User, Car).

*   **Минусы:**
*   **Нагрузка на чтение:** Данные разбросаны по диску, добавляется лишний JOIN при выборке данных.
*   **Увеличение общего количества транзакций**: Чтобы создать объект со всеми связями, нужно сделать INSERT в основную таблицу + по одному INSERT в каждую Join Table.

### Пример оптимизации: Механика блокировок при наличии FK-колонок

Когда вставляется или обновляется запись в таблице с внешними ключами, база выполняет каскад блокировок:

*   **На дочернюю запись (которую меняете):** Накладывается **Exclusive Lock (X)** (аналог `FOR UPDATE`). Никто другой не может изменять эту строку до завершения транзакции.
*   **На родительские записи (на которые ведут ссылки):** База накладывает **Shared Lock (S)** (аналог `FOR SHARE`). Это гарантирует, что пока создается связь, родительская запись не будет удалена или изменена.

**Проблема масштабирования:**
Если в таблице 5+ FK-колонок, то при каждой вставке база должна совершить 5 "прыжков" в разные индексы/таблицы и поставить там 5 Shared-блокировок. Это приводит к:
1.  **Росту Read IO:** Огромное количество чтений только для проверки целостности.
2.  **Риску Deadlock:** Чем больше объектов блокируется "одним махом", тем выше шанс взаимной блокировки транзакций(Deadlock), идущих в разном порядке.

#### Join Table как способ «разгрузки» БД
Вынос связей в промежуточные таблицы изолирует изменения и распределяет нагрузку.

**А) Уменьшение «ширины» блокировки основной таблицы**
Если все связи хранятся в основной таблице, любое изменение связи блокирует **всю строку** объекта.
*   *Пример:* При обновлении `manager_id` у пользователя, другой процесс в это же время хочет поменять его `department_id`. Они будут ждать друг друга, так как конкурируют за одну строку в `Users`.
*   *С Join Table:* Обновление менеджера идет в таблицу `user_managers`, а департамента — в `user_departments`. Это **разные физические строки** в разных таблицах. Конфликта блокировок нет.

**Б) Снижение вероятности Deadlock**
Разделение связей по разным таблицам сокращает количество ресурсов, которые нужно заблокировать одновременно при создании сущности. Запись в основную таблицу становится "легкой", так как в ней больше нет десятка FK-проверок.

### Пример оптимизации: Полиморфные связи и решение антипаттерна «Эксклюзивная дуга» (Рабочий пример)

**Проблема (Как было):**
При необходимости привязывать один объект (например, **Родовой сертификат / ЭРС**) к разным типам учреждений (Роддом, Поликлиника, Женская консультация), таблица превращается в «свалку» внешних ключей.
То есть под разные дочерние типы, создаются отдельные колонки FK.

**Антипаттерн «Эксклюзивная дуга»:**
В таблице `ERS_Blanks` создается множество колонок:
* `id`, `number`
* `roddom_id` (заполнено только для родов)
* `poly_id` (заполнено только для посещений ребенка)
* `consult_id` (заполнено только для посещений роженицы)
* `..._id` (приходится добавлять новую колонку при появлении любого нового типа учреждения)

**Итог:** в строке ЭРС бланка всегда заполнен только один FK из десяти. 90% ячеек в этих колонках — это `NULL`. Таблица становится тяжелой, индексы раздуваются, а любая модификация требует `ALTER TABLE`.

**Решение: Изоляция через Join Tables**
Мы полностью очищаем таблицу `ERS_Blanks` от знаний о внешних учреждениях. Она содержит только свои данные (номер, статус, дата выдачи). Связи выносятся в отдельные таблицы:

1. **ers_roddom_links**: `(ers_id, roddom_id)`
2. **ers_poly_links**: `(ers_id, poly_id)`
3. **ers_consult_links**: `(ers_id, consult_id)`

#### Преимущества такого подхода:

1. **Соблюдение Open-Closed Principle:**
   При добавлении нового типа (например, «Стоматология»), нам **не нужно менять** основную таблицу `ERS_Blanks`. Мы просто создаем новую связующую таблицу `ers_dentist_links`. Старый код и существующие миграции остаются нетронутыми.
2. **Отсутствие NULL-записей:**
   База данных хранит только реально существующие связи. Если сертификат выдан в ЖК, запись появится только в таблице `ers_consult_links`. Это экономит место и делает структуру прозрачной.
3. **Производительность индексов:**
   Базе гораздо быстрее просканировать маленькую таблицу связей из двух колонок (пара ID), чем искать нужный сертификат в огромной таблице с десятком пустых FK-полей и тяжелыми индексами по ним.
4. **Разделение ответственности (Encapsulation):**
   Каждое ведомство (ЖК, Роддом, Поликлиника) «владеет» своей таблицей связей. Им не нужно знать о структуре друг друга или о том, какие еще типы учреждений существуют в системе.

### Итог, когда что использовать:
Используйте FK колонку, если вы на 100% уверены, что связь всегда будет «один ко многим» и вам критична максимальная производительность простых выборок.
Используйте Join Table, если ваша таблица — это «горячая точка» (Hot Spot), куда постоянно пишут данные и где много связей. А также Если вы предвидите расширение системы, планируете хранить детали связи или хотите держать основные таблицы максимально независимыми.

## <a id="sharding-p">Шардирование (Sharding)</a> 

**Шардирование** — это стратегия «разделяй и властвуй». Вместо того чтобы покупать один супер-дорогой сервер, мы распределяем данные между несколькими обычными серверами. Каждая часть базы (шард) содержит только подмножество данных.

### Как это работает (Пример с пользователями)
Представь, что у тебя 100 миллионов пользователей. В одну таблицу они не влезают. Мы ставим два сервера:
* **Шард №1:** Хранит пользователей с ID от 1 до 50 000 000.
* **Шард №2:** Хранит пользователей с ID от 50 000 001 до 100 000 000.

Когда приходит запрос `SELECT * FROM users WHERE id = 10`, приложение идет сразу на Шард №1.

### Почему Join Table удобнее при шардировании?
Представим ситуацию Highload-проекта: данных стало так много, что они не влезают на один сервер. Мы решаем разделить их:
*   **Сервер А:** Хранит таблицу `Users`.
*   **Сервер Б:** Хранит таблицу `Cars`.

#### Проблема Foreign Key в колонке:
Если `user_id` (внешний ключ) лежит прямо в таблице `Cars` на **Сервере Б**, база данных сталкивается с техническим тупиком. При вставке новой машины база должна проверить: «А существует ли такой пользователь?».
*   **Сетевой барьер:** Механизм Foreign Key в классических РСУБД (PostgreSQL, MySQL) работает только в рамках **одного физического сервера**. База на Сервере Б не может «сходить по сети» на Сервер А, чтобы проверить наличие юзера.
*   **Итог:** Физический Foreign Key становится невозможным. Целостность данных теряется, и её приходится проверять только кодом в Java.

#### Преимущество Join Table (Таблица связей):
При использовании промежуточной таблицы `user_car`, мы можем вынести её на **Сервер В** (координатор связей).
1.  **Автономность:** Таблицы `Users` и `Cars` остаются «чистыми» и независимыми. Они ничего не знают о связях друг друга на уровне схемы.
2.  **Масштабируемость:** Если количество связей вырастет до миллиардов, мы сможем шардировать (разделить) саму таблицу `user_car` отдельно от таблиц пользователей и машин.
3.  **Гибкость:** Мы можем хранить таблицу связей на самом быстром железе (например, в RAM-диске), обеспечивая мгновенный поиск владельцев, в то время как тяжелые данные (профили с фото) будут лежать на дешевых дисках.

### Плюсы и Минусы Шардирования

| Плюсы | Минусы |
| :--- | :--- |
| **Бесконечный рост:** Можно добавлять новые сервера по мере роста нагрузки. | **Сложность JOIN-ов:** Нельзя «джойнить» таблицы, лежащие на разных серверах (приходится склеивать данные в Java-коде). |
| **Отказоустойчивость:** Если один сервер (шард) выйдет из строя, остальные данные будут доступны. | **Транзакции:** Распределенные транзакции (между серверами) работают крайне медленно и сложно. |
| **Производительность:** Каждый сервер работает со своим маленьким индексом, что быстрее, чем один гигантский. | **Сложность миграции:** Процесс «перешардирования» (перераспределения данных) — это тяжелая и долгая операция. |

**Вердикт:** Для монолитных приложений на одном сервере Join Table — это лишнее усложнение. Но для архитектуры Highload — это необходимый инструмент для обеспечения гибкости и возможности горизонтального масштабирования.

## <a id="sequences-p">Работа с последовательностями (Sequences)</a> 

**Sequence** — это независимый объект в базе данных, предназначенный для генерации уникальных числовых значений (обычно для Primary Keys).

### Проблема рассинхронизации (Duplicate Key Error)
Типичный баг: база данных выдает ошибку уникальности при вставке, хотя визуально ID должен быть свободен.

* **Причина:** Прямая вставка в таблицу в обход генератора `INSERT INTO users (id, name) VALUES (9, 'Admin')`. База запишет ID=9, но объект Sequence об этом не узнает. Он продолжит выдавать 5, 6, 7... и на попытке выдать 9-ку "споткнется" об уже существующую запись.
* **Как починить (PostgreSQL):** Нужно принудительно синхронизировать сиквенс с данными в таблице:
  `SELECT setval('users_id_seq', (SELECT max(id) FROM users));`
  Эта команда выставляет текущее значение сиквенса равным максимальному ID в таблице.

### Параметры настройки Sequence
При создании или изменении сиквенса можно задать его "поведение":

* **START WITH:** Начальное значение. Позволяет зарезервировать первые N значений под системные нужды.
* **INCREMENT BY:** Шаг приращения. По умолчанию 1. Если установить 100, сиквенс будет выдавать `1, 101, 201...`, создавая свободные промежутки ("люфт") в 99 ID между записями.
* **MINVALUE / MAXVALUE:** Границы генерации.
* **CACHE:** Позволяет базе заранее выделить группу чисел в память. Это ускоряет работу: если шаг большой, приложение может брать пачку ID и не дергать базу на каждый `INSERT`. Однако при падении сервера "закэшированные" числа будут потеряны (появятся пропуски в ID).

## <a id="surrogate-key-p">Сравнение суррогатных ключей: BIGINT против UUID</a> 

Выбор типа ключа определяет, насколько легко будет масштабировать систему в будущем и насколько быстро будут работать индексы.

### 1. Что такое UUID / GUID?
**UUID (Universally Unique Identifier)** — это 128-битный идентификатор, гарантирующий уникальность в масштабах всей компьютерной системы (и даже мира) без обращения к центральному серверу.
*   **Внешний вид:** 32 шестнадцатеричные цифры, разделенные дефисами (например, `550e8400-e29b-41d4-a716-446655440000`).
*   **GUID (Globally Unique Identifier):** Термин-синоним, чаще используемый в экосистеме Microsoft. Это реализация того же стандарта.

### Сравнение характеристик

| Характеристика | BIGINT (8 байт)                                                                  | UUID (16 байт)                                                                                                                                                                                                                                                                     |
| :--- |:---------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Генерация** | Только БД (Sequence/Identity). Требует сетевого запроса к базе.                  | Можно генерировать в коде (Java/JS) без участия БД. В распределенных системах (микросервисах) это критично: если у тебя 10 серверов создают заказы, им не нужно ждать ответа от одного общего сиквенса в БД, чтобы получить ID. Коллизии (совпадения) UUID практически невозможны. |
| **Производительность** | **Высокая.** Данные растут последовательно, индекс не фрагментируется. | **Ниже.** Классический UUID (v4) — это случайная строка. При вставке в B-Tree индекс базе приходится постоянно перестраивать дерево в разных местах, что дико замедляет запись (Random I/O). Целые числа всегда растут в конец, что очень эффективно                               |
| **Безопасность** | Низкая. Если  ссылка ://site.com, злоумышленник может просто перебрать 124, 125. | Высокая. Угадать следующий ID невозможно.                                                                                                                                                                                                                                          |
| **Размер** | Компактный. Занимает меньше места в RAM и на диске. BIGINT — 8 байт | Громоздкий. Занимает 16 байт. Индексы по UUID растут в 2-4 раза быстрее.                                                                                                                                                |
| **Идемпотентность** | **Сложно.** Чтобы отправить повторный запрос на создание, нужно сначала спросить у базы "какой следующий ID?". | **Идеально.** Клиент сам генерирует UUID и отправляет его в заголовке `Idempotency-Key`. База просто не создаст запись, если такой ID уже есть. |
| **Объединение баз** | **Проблема.** При слиянии двух таблиц (например, из разных регионов) ID 1, 2, 3... неизбежно совпадут. | **Просто.** Записи из разных баз гарантированно не перепутаются благодаря глобальной уникальности. |

### Когда что выбирать?

**Выбирай BIGINT, если:**
* У тебя монолитное приложение и одна база данных.
* Важна максимальная скорость вставки (High throughput).
* Нужно экономить место на диске и в индексах.

**Выбирай UUID, если:**
* У тебя **микросервисы** или шардированная БД. Нужно генерировать глобальный ID на клиенте/сервере так, чтобы они гарантированно не совпали с ID из другой базы.
* Нужно скрыть от пользователя количество записей (чтобы по ID нельзя было понять, что это 10-й заказ в магазине).
* Ты используешь **Offline-first** приложения (когда телефон создает запись без интернета и позже синхронизирует её с базой).
* Ты планируешь **слияние баз данных** или синхронизацию данных из разных источников.

### Решение проблемы фрагментации UUID
Если очень нужен UUID, но пугает медленная вставка, используют **UUID v7** (Time-based). Он содержит в себе метку времени в начале, поэтому новые UUID всегда больше старых. Это позволяет базе вставлять их в конец индекса почти так же быстро, как обычные числа.


<a id="transactions-acid"></a>
## Транзакции и ACID

**Транзакция** — это логическая единица работы с БД, которая переводит базу из одного согласованного состояния в другое. Она гарантирует, что группа SQL-запросов либо выполнится целиком, либо не выполнится вовсе.

### Свойства ACID (Фундамент надежности)

| Свойство | Определение | Механизм реализации |
| :--- | :--- | :--- |
| **A - Atomicity** (Атомарность) | "Все или ничего". Транзакция не может быть выполнена частично. Если один запрос упал — откатывается всё. | **Undo Log / Transaction Status**: БД отслеживает статус и откатывает изменения, если не было `COMMIT`. |
| **C - Consistency** (Согласованность) | База данных переходит из одного валидного состояния в другое. Все бизнес-правила соблюдены. | **Constraints**: Проверка `FOREIGN KEY`, `UNIQUE`, `CHECK`. Если нарушены — автоматический `ROLLBACK`. |
| **I - Isolation** (Изоляция) | Параллельные транзакции не должны видеть промежуточные (незакоммиченные) результаты друг друга. | **MVCC (xmin/xmax)**: Механизм многоверсионности, позволяющий читать данные без блокировок. |
| **D - Durability** (Надежность) | Если пришел ответ `COMMIT`, данные гарантированно сохранены даже при внезапном отключении питания. | **WAL (Write Ahead Log)**: Запись изменений в лог на диск происходит ДО внесения правок в файлы данных. |

### Механизм MVCC (Multi-Version Concurrency Control): Как база понимает, что «видеть»?

**MVCC** — это механизм, позволяющий читать данные без блокировок. Вместо изменения строки «на месте», база создает новую версию.
*   **xmin**: ID транзакции-создателя.
*   **xmax**: ID транзакции-удаления.

**Виртуальное разделение:** Каждая транзакция видит свой «снимок» (Snapshot) данных. Читатели никогда не блокируют писателей, а писатели — читателей.

В PostgreSQL каждая строка имеет скрытые системные поля:
*   **xmin** — ID транзакции, которая создала (INSERT) строку.
*   **xmax** — ID транзакции, которая удалила или обновила (DELETE/UPDATE) строку.

**PostgreSQL не переписывает данные в строке, а создает новую версию.

#### Пример: Эволюция баланса пользователя (ID: 1)
Представим, что сейчас идет **Транзакция №105** (уровень *Read Committed*).

| Версия | Данные (Баланс) | xmin | xmax | Статус для Т105 | Почему? |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **V1** | 100 руб. | 50 | 80 | **Не видна** | Удалена (xmax=80), транзакция 80 давно завершена. |
| **V2** | 200 руб. | 80 | 110 | **ВИДНА** | Создана Т80 (80 < 105), а Т110 еще не закоммичена. |
| **V3** | 300 руб. | 110 | 0 | **Не видна** | Создана Т110. Для Т105 она еще "в будущем" или не закоммичена. |

> **Суть изоляции:**
> * Это механизм, заставляющий БД игнорировать незакоммиченные изменения или даже закоммиченные, но произошедшие после начала вашей транзакции (в зависимости от уровня).
> * База фильтрует строки «на лету». Т105 видит «срез» реальности, где баланс равен 200, хотя в таблице физически лежат три версии этой строки.

### Уровни изоляции

| Уровень | Описание                                                                                                                              | Проблема                                                                                               |
| :--- |:--------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------|
| **Read Committed** | Видим только то, что закоммичено на момент начала **каждого запроса**. (защита от незакомиченных данных)                              | **Non-repeatable read**: одна и та же строка может измениться между двумя SELECT.   |
| **Repeatable Read** | Видим данные, закоммиченные на момент начала **всей транзакции**.  (защита изменененний данных при повторном чтении)                  | **Phantom Read**: появление новых строк в выборке (в Postgres защищен).                    |
| **Serializable** | Полная эмуляция последовательного выполнения. (защита от изменений)                                                                   | **Serialization Error**: откат при конфликте параллельных правок.                                |

### В чем разница между Изоляцией и Блокировкой?

Изоляция не всегда спасает от **Lost Update** (когда второй коммит затирает первый) в Race Condition. Для этого нужны явные блокировки:

1.  **FOR SHARE:** Блокирует изменение строки, но разрешает другим её читать и тоже вешать `FOR SHARE`. (Нужно для гарантии, что FK не удалят).
2.  **FOR UPDATE:** Полный захват. Никто не может изменить или даже прочитать строку с целью блокировки.
    *   **SKIP LOCKED:** Позволяет пропустить занятые строки (идеально для очередей и джоб).

Изоляция работает на все запросы транзакции «сверху». Блокировка — это более гибкий инструмент, позволяет точечно гарантировать, что данные в строке не изменятся другими процессами, пока принимается решение(не случится COMMIT или ROLLBACK).
Уровни изоляции лишь определяют видимость, а блокировка дает реальный контроль над ресурсом.



## <a id="locking-p">Блокировки в SQL: FOR UPDATE и FOR SHARE</a>
Exclusive Lock и Shared Lock — это фундаментальные названия механизмов, которые стоят за командами `FOR UPDATE` и `FOR SHARE`.

### **Shared Lock (S) — Разделяемая блокировка**
В SQL она вызывается командой **`FOR SHARE`**.

**Суть:** «Я читаю эту строку и запрещаю кому-либо её менять или удалять, пока я не закончу. Но другие тоже могут её читать и тоже вешать на неё свои Shared-блокировки».

- **Совместимость:** Много транзакций могут одновременно держать Shared Lock на одной и той же строке.
- **Зачем она при FK:** Когда вы вставляете заказ для `user_id = 10`, база автоматически вешает Shared Lock на строку пользователя №10. Это гарантирует, что пока создается заказ, пользователь не исчезнет.

Пример — гарантия неизменности данных при чтении:

```sql
-- Транзакция 1 (проверка заказа)
BEGIN;
SELECT * FROM orders WHERE id = 123 FOR SHARE;
-- Гарантируем, что заказ не изменится пока мы его обрабатываем
-- ... логика проверки
COMMIT;

-- Транзакция 2 (может читать параллельно)
BEGIN;
SELECT * FROM orders WHERE id = 123 FOR SHARE; -- ✅ Работает
-- Но не может изменить:
UPDATE orders SET status = 'cancelled' WHERE id = 123; -- ❌ Ждет!
```

### **Exclusive Lock (X) — Эксклюзивная блокировка**
В SQL она вызывается командой **`FOR UPDATE`** (или автоматически при `INSERT`/`UPDATE`/`DELETE`).

**Суть:** «Я хозяин этой строки. Никто не может её ни менять, ни даже вешать на неё `FOR SHARE`. Все остальные должны ждать, пока я не сделаю `COMMIT` или `ROLLBACK`».

- **Совместимость:** Только одна транзакция может держать Exclusive Lock. Она несовместима ни с чем.
- **Зачем она нужна:** Чтобы предотвратить ситуацию «потерянного обновления» (Lost Update), когда два процесса одновременно пытаются изменить одни и те же данные.

Пример использования — перевод денег:

```sql
-- Транзакция 1 (перевод денег)
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE; -- Блокируем для изменения
-- ... выполняем операцию перевода
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- Транзакция 2 (параллельный доступ)
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE; -- ❌ Ждет освобождения блокировки!
В данном случае FOR UPDATE предотвращает состояние гонки при финансовых операциях.
```

### Практические рекомендации
Используйте FOR UPDATE, когда: есть риск параллельных изменений одних данных, финансовые операции (переводы, платежи), смена статуса заказа.
Используйте FOR SHARE, когда: данные читаются для последующего принятия решения и нужно гарантировать их неизменность, формируется сложный отчет.

### Конфликты (Таблица совместимости)
Допустим одна транзакция уже держит блокировку, а вторая пытается ее получить:

| Тип блокировки        | Пытается взять Shared (S)                                   | Пытается взять Exclusive (X)                               |
|-----------------------|-------------------------------------------------------------|------------------------------------------------------------|
| Уже стоит Shared (S)  | ✅ Разрешено (Читатели не мешают читателям)                 | ❌ Ждет (Нельзя менять, пока кто-то читает)                 |
| Уже стоит Exclusive (X)| ❌ Ждет (Нельзя читать FOR SHARE, пока кто-то пишет)       | ❌ Ждет (Двое писать одновременно не могут)                 |

### Опасность при использовании внешних ключей FK
Когда используется FK-колонка, создается «перекресток» этих блокировок:

1. `INSERT` в дочернюю таблицу вешает **Exclusive (X)** на новую строку (чтобы её никто не трогал).
2. Но этот же `INSERT` идет в родительскую таблицу и вешает там **Shared (S)** на родителя.

**Проблема:** Если в этот момент другой процесс (например, админка) пытается обновить данные этого родителя (`UPDATE`), он пытается взять **Exclusive (X)** на него.
**Итог:** Админка «висит» и ждет, пока `INSERT` завершится. Если таких инсертов тысячи — база встает колом.

**Join Table решает это тем, что:**  
`UPDATE` родителя (основная инфо о юзере) и `INSERT` связи (в таблицу связей) — это разные строки в разных местах, и их блокировки `S` и `X` больше не сталкиваются на одной строке.

### PESSIMISTIC_READ VS PESSIMISTIC_WRITE
Что вы делаете сейчас:
В валидации заказа вы вызываете findAllAvailableByBasketId с PESSIMISTIC_READ

Проверяете, что товаров достаточно

НО сам заказ еще не создан!

Почему это НЕПРАВИЛЬНО:
PESSIMISTIC_READ означает:

"Я только читаю данные и не собираюсь их менять. Другие тоже могут читать, но НЕ МОГУТ ИЗМЕНЯТЬ?"

НЕТ! На самом деле:

Lock Mode	Другие READ	Другие WRITE
PESSIMISTIC_READ	✅ Разрешено	❌ Заблокировано (ожидают)
PESSIMISTIC_WRITE	✅ Разрешено	❌ Заблокировано
PESSIMISTIC_FORCE_INCREMENT	✅ Разрешено	❌ Заблокировано + version++
Критический момент: PESSIMISTIC_READ не блокирует другие PESSIMISTIC_READ!
Это shared lock (разделяемая блокировка).

2. СЦЕНАРИЙ LOST UPDATE (ПОТЕРЯННОЕ ОБНОВЛЕНИЕ)
   java
   // ПОЛЬЗОВАТЕЛЬ 1                           // ПОЛЬЗОВАТЕЛЬ 2
1. Заказ на 5 единиц товара X
2. Проверка: остаток 10 ✅
   SELECT ... LOCK IN SHARE MODE
3.                                         4. Заказ на 8 единиц товара X
                                           5. Проверка: остаток 10 ✅
                                              SELECT ... LOCK IN SHARE MODE
6. Создание заказа (ждем)                  7. Создание заказа (ждем)
8. UPDATE product SET count=5 WHERE id=X   9. UPDATE product SET count=2 WHERE id=X
   ИТОГ: Оба заказа созданы, но товара хватило только на один!
   Фактический остаток: 2
   Проданные товары: 13 ❌❌❌

3. ПРАВИЛЬНОЕ РЕШЕНИЕ
   ВАРИАНТ А: PESSIMISTIC_WRITE (РЕКОМЕНДУЮ)
   java
   @Lock(LockModeType.PESSIMISTIC_WRITE)  // Исключительная блокировка!
   @QueryHints(@QueryHint(name = "jakarta.persistence.lock.timeout", value = "3000")) // Таймаут 3 сек
   List<BasketProduct> findAllAvailableByBasketId(Long basketId);
   Почему:

Первый пользователь блокирует строки товаров

Второй пользователь ЖДЕТ или получает LockTimeoutException

Первый создает заказ, уменьшает остаток, коммитит

Второй видит актуальный остаток и может отказать




