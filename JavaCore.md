# Java Core & OOP
* ### [Абстрактные классы и Интерфейсы: Фундаментальные отличия](#Абстрактные-классы-и-Интерфейсы-Фундаментальные-отличия)

## Абстрактные классы и Интерфейсы: Фундаментальные отличия

Несмотря на появление `default` методов в интерфейсах, они остаются разными инструментами для разных задач.

### 1. Идеологическое отличие
* **Абстрактный класс (отношение **IS-A** / "является"):** Определяет **сущность** и её происхождение. Это каркас для тесно связанных объектов (например, `BaseService` для всех сервисов).
* **Интерфейс (отношение **CAN-DO** / "умеет"):** Определяет **поведение**, роль или контракт. Позволяет объединять абсолютно разные объекты (например, `Iterable` могут реализовать и `ArrayList`, и `MyCustomFileScanner`).

### 2. Техническое сравнение

| Характеристика | Абстрактный класс | Интерфейс (Java 8+) |
| :--- | :--- | :--- |
| **Наследование** | Одиночное (один `extends`). | Множественное (много `implements`). |
| **Состояние (Fields)** | Может иметь любые поля (private, protected, переменные). | Только константы (`public static final`). |
| **Конструктор** | Есть. Вызывается при создании наследника. | Нет. |
| **Методы с кодом** | Любые методы с любой логикой. | Только `default` и `static` методы. |
| **Модификаторы** | Доступны любые (private, protected). | Все методы по умолчанию `public`. |

### 3. Почему интерфейс не заменит абстрактный класс?
Главное отличие — **управление состоянием**.
Абстрактный класс может хранить переменные, которые меняются в процессе работы объекта, и предоставлять общие методы для работы с ними. Интерфейс — это "чистый" контракт. Если тебе нужно, чтобы у всех наследников было поле `private long id`, ты обязан использовать абстрактный класс.

### 4. Когда что выбирать?
1. Используй **Интерфейс**, когда хочешь описать общую способность для классов из разных веток (например, `Serializable`).
2. Используй **Абстрактный класс**, когда хочешь избежать дублирования кода в группе очень похожих классов и тебе нужно общее состояние.
